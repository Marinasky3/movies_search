const TypeDoc = require('typedoc')
const fs = require('fs-extra')

async function main() {
  const app = new TypeDoc.Application()

  app.options.addReader(new TypeDoc.TSConfigReader())
  app.options.addReader(new TypeDoc.TypeDocReader())

  app.bootstrap({
    tsconfig: 'tsconfig.prod.json',
    excludeExternals: true,
    entryPoints: ['./src/utils/propsTypedoc.ts'],
  })

  const project = app.convert()

  if (project) {
    const outputDir = 'dist/props'

    fs.ensureDirSync(outputDir)

    await app.generateJson(project, outputDir + '/allProps.json')

    let allProps = JSON.parse(
      fs.readFileSync(outputDir + '/allProps.json', 'utf-8')
    )

    // Group the interfaces by which component they're associated with
    const componentPropsInterfaces = allProps.children.reduce(
      (acc, interface) => {
        const componentName =
          interface && interface.sources[0].fileName
            ? interface.sources[0].fileName.split('/').reverse()[1]
            : null

        if (acc[componentName]) {
          acc[componentName].push(interface)
        } else {
          acc[componentName] = [interface]
        }

        return acc
      },
      {}
    )

    // Clean up the interfaces such that only the important information remains
    Object.entries(componentPropsInterfaces).forEach(
      ([componentName, interfaces]) => {
        componentProps = interfaces.reduce((acc, interface) => {
          if (interface.children) {
            const formattedPropsObject = interface.children.reduce(
              (acc, prop) => {
                const { name, kindString } = prop
                const properties =
                  kindString === 'Method' && prop.signatures?.length
                    ? prop.signatures[0]
                    : prop
                const formattedType = formatType(properties.type, interfaces)
                const required = !properties.flags.isOptional
                const description = properties.comment?.shortText
                const defaultValueTag = properties.comment?.tags?.find(
                  (tag) => tag.tag === 'defaultvalue'
                )
                const defaultValue = defaultValueTag?.text
                const deprecatedTag = properties.comment?.tags?.find(
                  (tag) => tag.tag === 'deprecated'
                )
                const deprecated = deprecatedTag?.text
                const remarksTag = properties.comment?.tags?.find(
                  (tag) => tag.tag === 'remarks'
                )
                const remarks = remarksTag?.text

                const fields = {
                  name,
                  type: formattedType,
                  required,
                  description,
                  defaultValue,
                  deprecated,
                  remarks,
                }

                acc.push(fields)
                return acc
              },
              []
            )

            acc[interface.name] = formattedPropsObject
          }
          return acc
        }, {})

        fs.writeFileSync(
          `${outputDir}/${componentName}.json`,
          JSON.stringify(componentProps)
        )
      }
    )
  }
}

function formatType(type, interfaces) {
  if (!type) {
    return ''
  } else if (type.type === 'union') {
    // Join the union of types into a string
    const joinedTypeString = type.types
      .reduce((acc, curr) => {
        if (curr.name) {
          acc.push(curr.name)
        } else if (curr.value) {
          acc.push(curr.value)
        }

        return acc
      }, [])
      .join(' | ')
  } else if (type.type === 'reference' && type.id) {
    // Resolve the reference
    referencedInterface = interfaces.find(
      (interface) => type.id === interface.id
    )

    return referencedInterface
      ? formatType(referencedInterface.type, interfaces)
      : ''
  } else {
    return type.name
  }
}

main().catch(console.error)
