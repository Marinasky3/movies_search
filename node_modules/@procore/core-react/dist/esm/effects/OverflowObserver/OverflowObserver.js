import React from 'react';
// Browsers occasionally miscalculate scroll and client width/height by one pixel up or down
//  so we're use |x| > 1 instead of x > 0 assertion eliminating the issue at the cost of
//  a false-negative result if the content is overflowing by just 1 pixel
function isContentOverflowing(length, visibleLength) {
    return Math.abs(length - visibleLength) > 1;
}
function isContentOverflowingX(node) {
    return isContentOverflowing(node.scrollWidth, node.clientWidth);
}
function isContentOverflowingY(node) {
    return isContentOverflowing(node.scrollHeight, node.clientHeight);
}
export function useOverflowObserver() {
    var _a = React.useState(false), isOverflowingX = _a[0], setIsOverflowingX = _a[1];
    var _b = React.useState(false), isOverflowingY = _b[0], setIsOverflowingY = _b[1];
    var ref = function (node) {
        if (!node) {
            return;
        }
        var newIsOverflowingX = isContentOverflowingX(node);
        if (newIsOverflowingX !== isOverflowingX) {
            setIsOverflowingX(newIsOverflowingX);
        }
        var newIsOverflowingY = isContentOverflowingY(node);
        if (newIsOverflowingY !== isOverflowingY) {
            setIsOverflowingY(newIsOverflowingY);
        }
    };
    return {
        ref: ref,
        isOverflowingX: isOverflowingX,
        isOverflowingY: isOverflowingY,
        isOverflowing: isOverflowingX || isOverflowingY,
    };
}
export function OverflowObserver(_a) {
    var children = _a.children;
    var _b = useOverflowObserver(), ref = _b.ref, isOverflowing = _b.isOverflowing, isOverflowingX = _b.isOverflowingX, isOverflowingY = _b.isOverflowingY;
    if (typeof children !== 'function') {
        console.warn("OverflowObserver: expected a function as \"children\" prop, received ".concat(typeof children));
        return children;
    }
    return children({ ref: ref, isOverflowing: isOverflowing, isOverflowingX: isOverflowingX, isOverflowingY: isOverflowingY });
}
//# sourceMappingURL=OverflowObserver.js.map