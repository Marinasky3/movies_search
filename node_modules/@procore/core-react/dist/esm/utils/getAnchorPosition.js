var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { defaultRect } from './dom';
// UTILS
function getComponents(placement) {
    var _a = placement.split('-'), primary = _a[0], secondary = _a[1];
    var edge = primary;
    var align = secondary || 'center';
    return { edge: edge, align: align };
}
function fromComponents(_a) {
    var align = _a.align, edge = _a.edge;
    return align === 'center' ? edge : "".concat(edge, "-").concat(align);
}
function getContainer() {
    return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        bottom: window.innerWidth,
        right: window.innerWidth,
    };
}
function flip(current) {
    var opposite = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left',
        center: 'center',
    };
    return opposite[current];
}
// GENERIC POSITION UPDATER (Edge, Align)
// Flip updater if validator fails and opposite passes
function getPositionComponent(_a) {
    var validator = _a.validator, updater = _a.updater;
    return function (_a) {
        var container = _a.container, target = _a.target, overlay = _a.overlay, current = _a.placement, _b = _a.canFlip, canFlip = _b === void 0 ? true : _b;
        var opposite = flip(current);
        var shouldFlip = !validator[current](container, target, overlay) &&
            validator[opposite](container, target, overlay);
        var placement = canFlip && shouldFlip ? opposite : current;
        return __assign({ placement: placement }, updater[placement](target, overlay));
    };
}
// PRIMARY
var Edge = {
    updater: {
        left: function (target, overlay) { return ({
            left: target.left - overlay.width,
        }); },
        right: function (target, overlay) { return ({ left: target.right }); },
        top: function (target, overlay) { return ({
            top: target.top - overlay.height,
        }); },
        bottom: function (target, overlay) { return ({ top: target.bottom }); },
    },
    validator: {
        top: function (container, target, overlay) {
            return target.top - container.top >= overlay.height;
        },
        left: function (container, target, overlay) {
            return target.left - container.left >= overlay.width;
        },
        bottom: function (container, target, overlay) {
            return container.height - target.bottom >= overlay.height;
        },
        right: function (container, target, overlay) {
            return container.width - target.right >= overlay.width;
        },
    },
};
// SECONDARY
export var Alignment = {
    updater: {
        left: function (target, overlay) { return ({ left: target.left }); },
        right: function (target, overlay) { return ({ left: target.right - overlay.width }); },
        top: function (target, overlay) { return ({ top: target.top }); },
        bottom: function (target, overlay) { return ({ top: target.bottom - overlay.height }); },
        center: function (target, overlay) { return ({
            left: target.left + (target.width - overlay.width) / 2,
            top: target.top + (target.height - overlay.height) / 2,
        }); },
    },
    validator: {
        top: function (container, target, overlay) {
            return container.height - target.top >= overlay.height;
        },
        right: function (container, target, overlay) {
            return target.right - container.left >= overlay.width;
        },
        left: function (container, target, overlay) {
            return container.width - target.left >= overlay.width;
        },
        bottom: function (container, target, overlay) {
            return target.bottom - container.top >= overlay.height;
        },
        center: function () { return true; },
    },
};
export var getAlignmentPosition = getPositionComponent(Alignment);
export var getEdgePosition = getPositionComponent(Edge);
export var padding = function (pad, shape) {
    if (pad === void 0) { pad = 0; }
    return (__assign(__assign({}, shape), { width: shape.width + pad * 2, height: shape.height + pad * 2, top: shape.top - pad, bottom: shape.bottom + pad, left: shape.left - pad, right: shape.right + pad }));
};
export function getAnchorPosition(placement, pad, container, target, overlay, canFlip) {
    if (pad === void 0) { pad = 0; }
    if (container === void 0) { container = getContainer(); }
    if (canFlip === void 0) { canFlip = true; }
    if (!target || !overlay) {
        return defaultRect;
    }
    var components = getComponents(placement);
    var align = getAlignmentPosition({
        canFlip: canFlip,
        container: container,
        target: target,
        overlay: overlay,
        placement: components.align,
    });
    var edge = getEdgePosition({
        canFlip: canFlip,
        container: container,
        target: padding(pad, target),
        overlay: overlay,
        placement: components.edge,
    });
    return __assign(__assign(__assign({}, align), edge), { placement: fromComponents({ align: align.placement, edge: edge.placement }), minWidth: target.width });
}
//# sourceMappingURL=getAnchorPosition.js.map