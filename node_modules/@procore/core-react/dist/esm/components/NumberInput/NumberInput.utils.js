import { getFormatterLocale } from '../../utils/i18n';
import { fillDecimalScaleVariant, } from './NumberInput.types';
export var defaultLocale = 'en-US';
export var minus = '-';
export var emptyString = '';
export var leftBrace = '(';
export var rightBrace = ')';
export var backspaceKey = 'Backspace';
export var deleteKey = 'Delete';
export var numericKeypadDel = 'Del'; // for delete key from numeric keypad in IE
export var periodKey = '.';
export var numericKeypadDecimal = 'Decimal'; // for period key from numeric keypad in IE
export var numericKeypadKey = 'Del'; // for delete key from numeric keypad in IE
export var androidUnidentifiedKey = 'Unidentified';
export var maxDigitLength = 15; // Safe length to avoid the loss of precision
export var maxDecimalScale = maxDigitLength - 1;
export var commaKey = ',';
export var metaKeyIdentifier = 'Meta';
export var controlKey = 'Control';
export var highlightAllKey = 'a';
export var copyKey = 'c';
// fixes binary rounding issues (e.g: (0.615).toFixed(2) returns 0.61)
export function toFixed(value, precision) {
    var isExponentialRecord = value.toString().includes('e');
    if (isExponentialRecord)
        return value;
    return Number(Number(Math.round(Number(value + 'e' + precision)) + 'e-' + precision).toFixed(precision));
}
export function formatterFactory(formatterLocale, options) {
    if (options === void 0) { options = {}; }
    try {
        return new Intl.NumberFormat(formatterLocale, options);
    }
    catch (error) {
        console.error("@procore/core-react Intl.NumberFormat error for locale ".concat(formatterLocale, ". Will fall back to en-US"), error);
        return new Intl.NumberFormat('en-US', options);
    }
}
export function getSeparators(locale) {
    var formatterLocale = getFormatterLocale(locale);
    var formatter = formatterFactory(formatterLocale);
    var value = formatter.format(1e9 + 0.1);
    var refinedValue = value.replace(new RegExp(/\d/, 'g'), emptyString);
    return {
        decimal: refinedValue.slice(-1),
        group: refinedValue.slice(-2, -1),
    };
}
// Check if a valid numeric string is a negative value
export var isValidNegative = function (value) {
    var _a;
    value = String(value);
    var minusRegExp = new RegExp("".concat(minus), 'g');
    var numberOfMinuses = (_a = value.match(minusRegExp)) === null || _a === void 0 ? void 0 : _a.length;
    var containsValidParenthesis = value.indexOf(leftBrace) === 0 &&
        value.indexOf(rightBrace) === value.length - 1;
    var isNegative = (numberOfMinuses === 1 && !containsValidParenthesis) ||
        (!numberOfMinuses && containsValidParenthesis);
    return isNegative;
};
export function verifyDecimalScale(decimalScale) {
    if (decimalScale === true) {
        return maxDecimalScale;
    }
    if (decimalScale === false) {
        return 0;
    }
    if (decimalScale < 0) {
        console.warn("WARNING: Decimal scale (".concat(decimalScale, ") is out of range. It was reset to 0. Possible values are from 0 to ").concat(maxDecimalScale, "."));
        return 0;
    }
    if (decimalScale > maxDecimalScale) {
        console.warn("WARNING: Decimal scale (".concat(decimalScale, ") is out of range. It was reset to the max value of ").concat(maxDecimalScale, ". Possible values are from 0 to ").concat(maxDecimalScale, "."));
        return maxDecimalScale;
    }
    return decimalScale;
}
export function unformat(locale, value, isNumericString) {
    if (isNumericString === void 0) { isNumericString = false; }
    var isValueNegative = isValidNegative(value);
    var decimal = isNumericString || typeof value === 'number'
        ? periodKey
        : getSeparators(locale).decimal;
    var numericRegExp = new RegExp("[^0-9".concat(decimal, "]"), 'g');
    var strValue = String(value);
    // Normalize value with numeric characters
    strValue = strValue.replace(numericRegExp, emptyString);
    // Normalize "minus" sign for negatives
    if (isValueNegative) {
        strValue = "".concat(minus).concat(strValue);
    }
    // Normalize integer and fraction parts of the value
    var _a = strValue.split(decimal), integer = _a[0], fractions = _a.slice(1);
    var fraction = fractions.join(emptyString);
    return {
        integer: integer,
        decimal: strValue.includes(decimal) ? decimal : emptyString,
        fraction: fraction,
        parsedNumber: parseFloat("".concat(integer).concat(periodKey).concat(fraction)),
    };
}
export function refineIntegerFromLeadingZeroes(integer) {
    var isNegativeValue = isValidNegative(integer);
    var refinedFromMinus = integer.replace(minus, emptyString);
    var hasLeadingZeroes = refinedFromMinus.slice(0, 1);
    var refinedFromLeadingZeroes = refinedFromMinus.replace(/^0+/, emptyString);
    var zeroPadded = hasLeadingZeroes && refinedFromLeadingZeroes === emptyString;
    return "".concat(isNegativeValue ? minus : emptyString).concat(zeroPadded ? 0 : refinedFromLeadingZeroes);
}
export function getLengthInfo(locale, value, decimalScale, fillDecimalScale, isNumericString) {
    if (decimalScale === void 0) { decimalScale = 0; }
    if (fillDecimalScale === void 0) { fillDecimalScale = fillDecimalScaleVariant.none; }
    if (isNumericString === void 0) { isNumericString = false; }
    var isNegativeValue = isValidNegative(value);
    var _a = unformat(locale, value, isNumericString), integer = _a.integer, decimal = _a.decimal, fraction = _a.fraction;
    var integerRefinedFromLeadingZeros = refineIntegerFromLeadingZeroes(integer);
    var getIntegerLength = function () {
        var accountEmptyInteger = integer === emptyString && decimal && fraction.length > 0;
        if (accountEmptyInteger)
            return 1;
        var accountEmptyNegativeInteger = integer === minus && decimal && fraction.length > 0;
        if (accountEmptyNegativeInteger)
            return 2;
        var accountInteger = integer.length > 0 && integer !== emptyString && integer !== minus;
        if (accountInteger)
            return integerRefinedFromLeadingZeros.length;
        return 0;
    };
    var integerLength = getIntegerLength();
    var fractionLength = fraction.length;
    var length = integerLength + fractionLength;
    var safeLength = maxDigitLength + (isNegativeValue ? 1 : 0);
    var isSafeLength = safeLength - length > -1;
    var isDecimalScaleNonFillable = fillDecimalScale === fillDecimalScaleVariant.none;
    var safeIntegerLength = isDecimalScaleNonFillable
        ? safeLength
        : safeLength - decimalScale;
    var safeFractionLength = isDecimalScaleNonFillable
        ? Math.min(safeLength -
            integerRefinedFromLeadingZeros.slice(0, safeIntegerLength).length, decimalScale)
        : decimalScale;
    var isSafeIntegerLength = safeIntegerLength - integerLength > -1;
    var isSafeFractionLength = safeFractionLength - fractionLength > -1;
    var safelyTruncatedInteger = isSafeIntegerLength
        ? integerRefinedFromLeadingZeros
        : integerRefinedFromLeadingZeros.slice(0, safeIntegerLength);
    var safelyTruncatedFraction = isSafeFractionLength
        ? fraction
        : fraction.slice(0, safeFractionLength);
    var safelyTruncatedValue = "".concat(safelyTruncatedInteger).concat(decimal).concat(safelyTruncatedFraction);
    return {
        length: length,
        safeLength: safeLength,
        isSafeLength: isSafeLength,
        safelyTruncatedValue: safelyTruncatedValue,
        integerLength: integerLength,
        safeIntegerLength: safeIntegerLength,
        isSafeIntegerLength: isSafeIntegerLength,
        fractionLength: fractionLength,
        safeFractionLength: safeFractionLength,
        isSafeFractionLength: isSafeFractionLength,
    };
}
export function format(locale, decimalScale, fillDecimalScale, value, isNumericString) {
    if (isNumericString === void 0) { isNumericString = false; }
    var fixedDecimalScale = fillDecimalScale === fillDecimalScaleVariant.always;
    var fillDecimalScaleOnBlur = fillDecimalScale === fillDecimalScaleVariant.onBlur;
    var autoFilledScale = fixedDecimalScale || fillDecimalScaleOnBlur;
    var _a = getLengthInfo(locale, value, decimalScale, fillDecimalScale, isNumericString), length = _a.length, safeLength = _a.safeLength, isSafeLength = _a.isSafeLength, safelyTruncatedValue = _a.safelyTruncatedValue;
    var isTruncatedBeforeFormatting = autoFilledScale || !isSafeLength;
    var valueOfVerifiedLength = isTruncatedBeforeFormatting
        ? safelyTruncatedValue
        : value;
    var _b = unformat(locale, valueOfVerifiedLength, isNumericString || typeof value === 'number'), integer = _b.integer, decimal = _b.decimal, fraction = _b.fraction;
    var options = {
        minimumFractionDigits: fixedDecimalScale
            ? decimalScale
            : Math.min(Math.max(0, (fraction === null || fraction === void 0 ? void 0 : fraction.length) || 0), decimalScale),
        maximumFractionDigits: decimalScale,
    };
    var formatterLocale = getFormatterLocale(locale);
    var formatter = formatterFactory(formatterLocale, options);
    var isDecimalAllowed = decimalScale > 0;
    var isEmptyValue = integer === emptyString && !decimal && !fraction;
    if (isEmptyValue)
        return emptyString;
    var isMinusValue = integer === minus && !decimal && !fraction;
    if (isMinusValue)
        return minus;
    var isDecimalValue = integer === emptyString && decimal && !fraction && !fixedDecimalScale;
    if (isDecimalValue)
        return isDecimalAllowed ? decimal : emptyString;
    var isMinusDecimalValue = integer === minus && decimal && !fraction && !fixedDecimalScale;
    if (isMinusDecimalValue)
        return "".concat(minus).concat(isDecimalAllowed ? decimal : emptyString);
    var isFractionValueWithEmptyInteger = (integer === minus || integer === emptyString) &&
        decimal &&
        (fraction || (!fraction && fixedDecimalScale));
    if (isFractionValueWithEmptyInteger) {
        var numberOfZerosToPad = decimalScale - fraction.length;
        var preparedFraction = numberOfZerosToPad > 0 && fixedDecimalScale
            ? fraction.concat(Array.from({ length: numberOfZerosToPad }, function (_) { return '0'; }).join(emptyString))
            : fraction.slice(0, decimalScale);
        return "".concat(integer).concat(isDecimalAllowed ? decimal : emptyString).concat(preparedFraction);
    }
    if (typeof valueOfVerifiedLength === 'number') {
        return formatter.format(valueOfVerifiedLength);
    }
    if (fraction) {
        var number = parseFloat("".concat(integer).concat(periodKey).concat(fraction.slice(0, options.maximumFractionDigits)));
        if (isNaN(number))
            return emptyString;
        return formatter.format(number);
    }
    if (integer) {
        var number = parseInt(integer, 10);
        if (isNaN(number))
            return emptyString;
        var formatted = formatter.format(number);
        var isDecimalAllowed_1 = !(options.minimumFractionDigits === 0 && options.maximumFractionDigits === 0);
        var isDecimalAvailable = decimal && !formatted.includes(decimal) && length < safeLength;
        return isDecimalAllowed_1 && isDecimalAvailable
            ? "".concat(formatted).concat(decimal)
            : formatted;
    }
    return emptyString;
}
export function identifyPressedKey(decimalSeparatorKey, inputType, pressedKey, prevValue, value) {
    if (pressedKey !== androidUnidentifiedKey)
        return pressedKey;
    if (inputType === 'deleteContentBackward')
        return backspaceKey;
    if (inputType === 'insertText') {
        var diff = value
            .split(emptyString)
            .find(function (char, i) { return char !== prevValue.split(emptyString)[i]; });
        switch (diff) {
            case decimalSeparatorKey:
                return decimalSeparatorKey;
            case minus:
                return minus;
            default:
                return pressedKey;
        }
    }
    return pressedKey;
}
export function getPressedKeyInfo(decimalSeparatorKey, group, pressedKey, prevCursorPosition, prevValue, verifiedDecimalScale) {
    var selectionStart = prevCursorPosition.selectionStart, selectionEnd = prevCursorPosition.selectionEnd, selection = prevCursorPosition.selection;
    var backspaceWasPressed = pressedKey === backspaceKey;
    var backspacedChar = backspaceWasPressed
        ? prevValue.slice(selectionStart + (selection ? 0 : -1), selectionEnd)
        : null;
    var decimalWasPressed = [
        decimalSeparatorKey,
        numericKeypadDecimal,
    ].includes(pressedKey);
    var decimalPressedForInteger = decimalWasPressed && verifiedDecimalScale === 0;
    var deleteWasPressed = [deleteKey, numericKeypadDel].includes(pressedKey);
    var deletedChar = deleteWasPressed
        ? prevValue.slice(selectionStart, selectionEnd + (selection ? 0 : 1))
        : null;
    var thousandsSeparatorWasBackspaced = backspaceWasPressed && backspacedChar === group;
    var thousandsSeparatorWasDeleted = deleteWasPressed && deletedChar === group;
    return {
        backspaceWasPressed: backspaceWasPressed,
        backspacedChar: backspacedChar,
        decimalWasPressed: decimalWasPressed,
        decimalPressedForInteger: decimalPressedForInteger,
        deleteWasPressed: deleteWasPressed,
        deletedChar: deletedChar,
        thousandsSeparatorWasBackspaced: thousandsSeparatorWasBackspaced,
        thousandsSeparatorWasDeleted: thousandsSeparatorWasDeleted,
    };
}
export function prepareValueToFormatting(decimal, decimalSeparatorKey, group, pressedKey, prevCursorPosition, prevValue, verifiedDecimalScale, value) {
    var _a = getPressedKeyInfo(decimalSeparatorKey, group, pressedKey, prevCursorPosition, prevValue, verifiedDecimalScale), decimalPressedForInteger = _a.decimalPressedForInteger, thousandsSeparatorWasBackspaced = _a.thousandsSeparatorWasBackspaced, thousandsSeparatorWasDeleted = _a.thousandsSeparatorWasDeleted;
    // Remove preceding/following integer digit instead of thousands separator
    if (thousandsSeparatorWasBackspaced || thousandsSeparatorWasDeleted) {
        var selectionEnd = prevCursorPosition.selectionEnd, selection_1 = prevCursorPosition.selection;
        var getCursorShift = function () {
            if (thousandsSeparatorWasDeleted) {
                var deletedAsSelection = selection_1 === group;
                return deletedAsSelection ? 0 : 1;
            }
            if (thousandsSeparatorWasBackspaced)
                return -2;
            return 0;
        };
        var indexOfIntegerDigitToRemove_1 = selectionEnd + getCursorShift();
        return prevValue
            .split(emptyString)
            .filter(function (_, i) { return i !== indexOfIntegerDigitToRemove_1; })
            .join(emptyString);
    }
    // Ignore typing decimal separator for integer
    if (decimalPressedForInteger) {
        return value.replace(new RegExp("[".concat(decimal, "]"), 'g'), emptyString);
    }
    return value;
}
export function getNewCursorPosition(decimal, decimalSeparatorKey, group, newValue, pressedKey, prevCursorPosition, prevValue, value, verifiedDecimalScale, locale, fillDecimalScale) {
    var fixedDecimalScale = fillDecimalScale === fillDecimalScaleVariant.always;
    var _a = getLengthInfo(locale, prevValue, verifiedDecimalScale, fillDecimalScale), prevLength = _a.length, prevFractionLength = _a.fractionLength;
    var _b = getLengthInfo(locale, newValue, verifiedDecimalScale, fillDecimalScale), newLength = _b.length, newSafeLength = _b.safeLength, newIntegerLength = _b.integerLength, newSafeIntegerLength = _b.safeIntegerLength, newFractionLength = _b.fractionLength, newSafeFractionLength = _b.safeFractionLength;
    var _c = getPressedKeyInfo(decimalSeparatorKey, group, pressedKey, prevCursorPosition, prevValue, verifiedDecimalScale), backspaceWasPressed = _c.backspaceWasPressed, backspacedChar = _c.backspacedChar, decimalWasPressed = _c.decimalWasPressed, deleteWasPressed = _c.deleteWasPressed, thousandsSeparatorWasBackspaced = _c.thousandsSeparatorWasBackspaced;
    var digitTyped = pressedKey && /\d/g.test(pressedKey);
    var digitBackspaced = backspaceWasPressed && backspacedChar && /\d/g.test(backspacedChar);
    var decimalBackspaced = backspaceWasPressed && backspacedChar === decimal;
    var selectionStart = prevCursorPosition.selectionStart, selectionEnd = prevCursorPosition.selectionEnd, selection = prevCursorPosition.selection;
    var defaultPosition = Math.max(selectionEnd + (newValue.length - prevValue.length), 0);
    var isPrevValueNegative = isValidNegative(prevValue);
    var isNewValueNegative = isValidNegative(newValue);
    var isDecimalAllowed = verifiedDecimalScale > 0;
    var digitTypedBeforeMinus = isPrevValueNegative && selectionEnd === 0 && digitTyped;
    var leadingZeroAdded = pressedKey === '0' && selectionEnd === (isPrevValueNegative ? 1 : 0);
    var prevIndexOfDecimalSeparator = prevValue.indexOf(decimal);
    var prevCursorPositionInDecimalArea = prevIndexOfDecimalSeparator > -1 &&
        prevIndexOfDecimalSeparator < selectionEnd;
    var prevCursorPositionInIntegerArea = prevIndexOfDecimalSeparator === -1 ||
        prevIndexOfDecimalSeparator >= selectionEnd;
    var filledIntegerScaleDigitWasChanged = digitTyped &&
        prevCursorPositionInIntegerArea &&
        selectionEnd !== prevValue.length &&
        newLength === prevLength &&
        (newLength === newSafeLength || newIntegerLength === newSafeIntegerLength);
    var isDecimalScaleFilled = isDecimalAllowed &&
        newFractionLength === prevFractionLength &&
        newFractionLength === newSafeFractionLength;
    var filledDecimalScaleDigitWasBackspaced = isDecimalScaleFilled && prevCursorPositionInDecimalArea && digitBackspaced;
    var filledDecimalScaleDigitWasChanged = isDecimalScaleFilled && prevCursorPositionInDecimalArea && digitTyped;
    // Manage cursor when decimalSeparator typed in a new place of a decimal-allowed number
    var decimalNewPosition = newValue.indexOf(decimal);
    var restructuredByDecimal = isDecimalAllowed && decimalWasPressed && decimalNewPosition > -1;
    // Preserve cursor after first typed digit and before decimal separator
    var fixedDecimalScaleFirstTyping = fixedDecimalScale &&
        value.length === (isNewValueNegative ? 2 : 1) &&
        newValue.charAt(isNewValueNegative ? 1 : 0) === pressedKey;
    // Preserve cursor before "negative" sign
    var isLeadingZerosRemovedOnPrecedingDigitBackspace = backspaceWasPressed &&
        defaultPosition === 0 &&
        selectionEnd - defaultPosition > 1;
    var keepCursorBeforeNegativeSign = isNewValueNegative && isLeadingZerosRemovedOnPrecedingDigitBackspace;
    var getPositionOnRestructuringByDecimal = function () {
        return prevCursorPositionInDecimalArea
            ? newValue.length
            : decimalNewPosition + 1;
    };
    var getPositionOnDecimalBackspace = function () {
        var removedCharShift = 1;
        var valueLength = newValue.length;
        if (prevFractionLength === 0) {
            return valueLength;
        }
        var delta = 0;
        var anchorDigitIndexFromTheEnd = 0;
        newValue
            .split(emptyString)
            .reverse()
            .forEach(function (char, i) {
            if (char === group) {
                delta++;
            }
            if (i - delta === prevFractionLength - 1) {
                anchorDigitIndexFromTheEnd = i;
            }
        });
        return valueLength - removedCharShift - anchorDigitIndexFromTheEnd;
    };
    var getPositionOnDelete = function () {
        var firstSymbolDeleted = selectionEnd === 0;
        if (firstSymbolDeleted) {
            return 0;
        }
        var removedCharShift = 1;
        var anchorDigitIndex = prevValue
            .slice(0, selectionEnd)
            .replace(new RegExp("[".concat(group, "]"), 'g'), emptyString).length - 1;
        var delta = 0;
        var cursorPosition = 0;
        newValue.split(emptyString).forEach(function (char, i) {
            if (char === group) {
                delta++;
            }
            if (i - delta === anchorDigitIndex) {
                cursorPosition = i;
            }
        });
        return cursorPosition + removedCharShift;
    };
    var getPositionOnFilledIntegerScaleDigitChange = function () {
        var getGroupsNumber = function (value, start, end) {
            var _a;
            return (((_a = value.slice(start, end).match(new RegExp("[".concat(group, "]"), 'g'))) === null || _a === void 0 ? void 0 : _a.length) ||
                0);
        };
        var numberOfGroupsBeforeCursorPrevValue = getGroupsNumber(prevValue, 0, selectionEnd);
        var numberOfGroupsBeforeCursorNewValue = getGroupsNumber(newValue, 0, selectionEnd + 1);
        var groupsDiffBeforeCursor = numberOfGroupsBeforeCursorNewValue - numberOfGroupsBeforeCursorPrevValue;
        var typedDigitShift = leadingZeroAdded ? 0 : 1;
        return selectionEnd + groupsDiffBeforeCursor + typedDigitShift;
    };
    var getPositionOnSelectionChange = function () {
        if (restructuredByDecimal)
            return getPositionOnRestructuringByDecimal();
        var getPasteText = function () {
            var beforeSelectionPartLength = prevValue.slice(0, selectionStart).length;
            var afterSelectionPartLength = prevValue.slice(selectionEnd).length;
            var valueWithoutBeforePart = value.slice(beforeSelectionPartLength);
            var pasteText = valueWithoutBeforePart.slice(0, valueWithoutBeforePart.length - afterSelectionPartLength);
            return pasteText;
        };
        var _a = unformat(locale, getPasteText()), pasteInteger = _a.integer, pasteDecimal = _a.decimal, pasteFraction = _a.fraction;
        var refinedPasteText = "".concat(selectionStart === 0
            ? refineIntegerFromLeadingZeroes(pasteInteger)
            : pasteInteger).concat(pasteDecimal).concat(pasteFraction);
        var refinedPasteTextLength = refinedPasteText.length;
        var anchorDigitIndexRaw = prevValue
            .slice(0, selectionStart)
            .replace(new RegExp("[".concat(group).concat(decimal, "]"), 'g'), emptyString).length -
            1;
        var anchorDigitIndexBase = anchorDigitIndexRaw > -1 ? anchorDigitIndexRaw : 0;
        var anchorDigitIndexShift = anchorDigitIndexRaw > -1
            ? refinedPasteTextLength
            : Math.max(refinedPasteTextLength - 1, 0);
        var anchorIndex = anchorDigitIndexBase + anchorDigitIndexShift;
        var getCursorPositionShift = function () {
            var negativeToPositiveConversion = isValidNegative(refinedPasteText) && isPrevValueNegative;
            var integerZeroBasedSelectionRemoval = refinedPasteTextLength === 0 && selectionStart === 0;
            var integerPartRemoved = integerZeroBasedSelectionRemoval &&
                selectionEnd === prevIndexOfDecimalSeparator;
            var fractionZeroBasedSelectionRemoval = (refinedPasteTextLength === 0 || refinedPasteText === minus) &&
                selectionStart === prevIndexOfDecimalSeparator + 1;
            var groupSelectionBackspaced = selection === group && thousandsSeparatorWasBackspaced;
            if (negativeToPositiveConversion || integerPartRemoved)
                return -1;
            if (integerZeroBasedSelectionRemoval || groupSelectionBackspaced)
                return 0;
            if (fractionZeroBasedSelectionRemoval)
                return 2;
            return 1;
        };
        var delta = 0;
        var cursorPosition = 0;
        for (var i = 0; i < newValue.length; i++) {
            var char = newValue.charAt(i);
            var isDeltaIncrementer = char === group || (char === decimal && !pasteDecimal);
            if (isDeltaIncrementer) {
                delta++;
            }
            if (i - delta === anchorIndex) {
                cursorPosition = i + getCursorPositionShift();
                break;
            }
            if (i + 1 === newValue.length) {
                cursorPosition = newValue.length;
            }
        }
        return cursorPosition;
    };
    var getNewPosition = function () {
        if (selection) {
            return getPositionOnSelectionChange();
        }
        if (digitTypedBeforeMinus) {
            return 2;
        }
        if (filledIntegerScaleDigitWasChanged) {
            return getPositionOnFilledIntegerScaleDigitChange();
        }
        if (deleteWasPressed) {
            return getPositionOnDelete();
        }
        if (decimalBackspaced) {
            return getPositionOnDecimalBackspace();
        }
        if (filledDecimalScaleDigitWasBackspaced) {
            return selectionEnd - 1;
        }
        if (filledDecimalScaleDigitWasChanged) {
            return selectionEnd + 1;
        }
        if (restructuredByDecimal) {
            return getPositionOnRestructuringByDecimal();
        }
        if (fixedDecimalScaleFirstTyping) {
            return isNewValueNegative ? 2 : 1;
        }
        if (keepCursorBeforeNegativeSign) {
            return 1;
        }
        return defaultPosition;
    };
    return getNewPosition();
}
//# sourceMappingURL=NumberInput.utils.js.map