var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { Computer } from '@procore/core-icons/dist';
import { findIndex, propEq, remove } from 'ramda';
import React from 'react';
import { ulid } from 'ulid';
import { mergeRefs } from '../../../effects/mergeRefs';
import { useResizeObserver } from '../../../effects/ResizeObserver';
import { useFileUploader } from '../../../effects/useFileUploader';
import { useI18nContext } from '../../../state/I18n';
import { DefaultMessage } from '../../Dropzone/Dropzone';
import { useDropzone } from '../../Dropzone/Dropzone.hooks';
import { dropErrors, } from '../../Dropzone/Dropzone.types';
import { useFileSelectContext } from '../../FileSelect';
import { dropzoneHeight, errorBannerMarginBottom, errorBannerMarginTop, listBorderWidth, listMarginTop, StyledDropzoneErrorBanner, StyledDropzoneWrapper, StyledLocalSource, StyledThumbnailList, uploaderHeight, } from './LocalSource.styles';
import { defaultListHeight, defaultRowHeight, } from '../ThumbnailList/ThumbnailList';
function defaultGetMethod() {
    return 'POST';
}
function defaultGetPayloadKey() {
    return 'file';
}
function defaultGetHeaders() {
    return {};
}
export var LocalSource = React.forwardRef(function LocalSource(_a, ref) {
    var _this = this;
    var sourceId = _a.sourceId, getEndpoint = _a.getEndpoint, _b = _a.getMethod, getMethod = _b === void 0 ? defaultGetMethod : _b, _c = _a.getPayloadKey, getPayloadKey = _c === void 0 ? defaultGetPayloadKey : _c, getPayload = _a.getPayload, _d = _a.getHeaders, getHeaders = _d === void 0 ? defaultGetHeaders : _d, uploadFile = _a.uploadFile, maxFileSize = _a.maxFileSize, minFileSize = _a.minFileSize, accept = _a.accept, dropzoneContentRenderer = _a.dropzoneContentRenderer, qa = _a.qa, beforeLocalFileUpload = _a.beforeLocalFileUpload;
    var I18n = useI18nContext();
    var _e = React.useState({}), uploadProgress = _e[0], setUploadProgress = _e[1];
    var fileUploader = useFileUploader({
        getEndpoint: getEndpoint,
        getMethod: getMethod,
        getPayloadKey: getPayloadKey,
        getPayload: getPayload,
        getHeaders: getHeaders,
        uploadFile: uploadFile,
    });
    var _f = useFileSelectContext(), register = _f.register, currentSource = _f.currentSource, maxFileNumber = _f.maxFileNumber, onChange = _f.onChange, setIsUploading = _f.setIsUploading, setIsError = _f.setHasError, onResetValue = _f.onResetValue, isModalOpen = _f.isModalOpen;
    var disabled = maxFileNumber < 1;
    var _g = React.useState([]), value = _g[0], setValue = _g[1];
    var _h = React.useState(), dropError = _h[0], setDropError = _h[1];
    React.useEffect(function () {
        var unregister = register(sourceId, {
            title: I18n.t('core.fileSelect.localFilesSource'),
            icon: React.createElement(Computer, null),
        });
        var unsubscribe = onResetValue(function () {
            setUploadProgress({});
            setValue([]);
            setDropError(undefined);
        });
        return function () {
            unsubscribe();
            unregister();
        };
    }, []);
    var uploadedValue = React.useMemo(function () {
        return value.filter(function (v) {
            var hasError = Boolean(v.error);
            var hasResponse = 'response' in v;
            return !hasError && hasResponse;
        });
    }, [value]);
    React.useEffect(function () {
        onChange(sourceId, uploadedValue);
    }, [uploadedValue]);
    React.useEffect(function () {
        if (!isModalOpen) {
            setDropError(undefined);
        }
    }, [isModalOpen]);
    // update error/uploading state in FileSelect sidebar
    React.useEffect(function () {
        var noItems = !value.length;
        var hasItemsPendingUpload = Object.values(uploadProgress)
            .map(function (progress) { return progress !== null && progress !== void 0 ? progress : 100; })
            .some(function (progress) { return progress < 100; });
        var hasItemsWithUploadError = value.some(function (_a) {
            var error = _a.error;
            return error;
        });
        if (noItems) {
            setIsUploading(sourceId, false);
            setIsError(sourceId, false);
        }
        else {
            setIsUploading(sourceId, hasItemsPendingUpload);
            setIsError(sourceId, hasItemsWithUploadError);
        }
    }, [value, uploadProgress]);
    if (currentSource !== sourceId) {
        return null;
    }
    var onChangeInternal = function (files) { return __awaiter(_this, void 0, void 0, function () {
        var shouldAttach, newFiles, updateFile, filesToUpload, initialUploadProgress;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!files.length)
                        return [2 /*return*/];
                    return [4 /*yield*/, beforeLocalFileUpload(files)];
                case 1:
                    shouldAttach = _a.sent();
                    if (!shouldAttach)
                        return [2 /*return*/];
                    newFiles = files.map(function (item) { return (__assign(__assign({}, item), { error: '', progress: 0 })); });
                    setValue(function (prevItems) { return __spreadArray(__spreadArray([], prevItems, true), newFiles, true); });
                    updateFile = function (fileId, payload) {
                        setValue(function (prev) {
                            return prev.map(function (v) {
                                if (v.id === fileId) {
                                    return __assign(__assign({}, v), payload);
                                }
                                return v;
                            });
                        });
                    };
                    filesToUpload = files.map(function (e) { return ({
                        id: e.id,
                        blob: e.src,
                    }); });
                    initialUploadProgress = filesToUpload.reduce(function (acc, cur) {
                        var _a;
                        return (__assign(__assign({}, acc), (_a = {}, _a[cur.id] = 0, _a)));
                    }, {});
                    setUploadProgress(function (prev) { return (__assign(__assign({}, prev), initialUploadProgress)); });
                    fileUploader.uploadFiles(filesToUpload, {
                        onComplete: function (id, response) {
                            updateFile(id, { response: response });
                            setUploadProgress(function (prev) {
                                var _a;
                                return (__assign(__assign({}, prev), (_a = {}, _a[id] = 100, _a)));
                            });
                        },
                        onCompleteAll: function () {
                            setIsUploading(sourceId, false);
                        },
                        onProgress: function (id, progress) {
                            setIsUploading(sourceId, true);
                            setUploadProgress(function (prev) {
                                var _a;
                                return (__assign(__assign({}, prev), (_a = {}, _a[id] = Math.min(99, progress), _a)));
                            });
                        },
                        onError: function (id) {
                            var error = I18n.t('core.fileExplorer.uploadFailed');
                            updateFile(id, { error: error });
                            setUploadProgress(function (prev) {
                                var _a;
                                return (__assign(__assign({}, prev), (_a = {}, _a[id] = 100, _a)));
                            });
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); };
    var onCancel = function (item) {
        setValue(function (prevItems) {
            return remove(findIndex(propEq('id', item.id), prevItems), 1, prevItems);
        });
        setUploadProgress(function (prev) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[item.id] = null, _a)));
        });
    };
    return (React.createElement(Uploader, { ref: ref, qa: qa, multiple: true, accept: accept, disabled: disabled, maxFileNumber: maxFileNumber, maxFileSize: maxFileSize, minFileSize: minFileSize, dropError: dropError, onDropError: setDropError, uploadedValue: uploadedValue, value: value.map(function (e) {
            var _a;
            return (__assign(__assign({}, e), { progress: (_a = uploadProgress[e.id]) !== null && _a !== void 0 ? _a : 0 }));
        }), onChange: onChangeInternal, onCancel: onCancel, dropzoneContentRenderer: dropzoneContentRenderer }));
});
var collapsedBannerThreshold = 116;
var spareHeightForListAccountingErrorBannerMaxHeight = 14;
var Uploader = React.forwardRef(function Uploader(_a, ref) {
    var value = _a.value, uploadedValue = _a.uploadedValue, onChange = _a.onChange, onCancel = _a.onCancel, onDrop = _a.onDrop, disabled = _a.disabled, multiple = _a.multiple, accept = _a.accept, dropError = _a.dropError, onDropError = _a.onDropError, qa = _a.qa, _b = _a.maxFileNumber, maxFileNumber = _b === void 0 ? Infinity : _b, minFileSize = _a.minFileSize, maxFileSize = _a.maxFileSize, dropzoneContentRenderer = _a.dropzoneContentRenderer;
    var dropzoneRootRef = React.useRef(null);
    var errorBannerRef = React.useRef(null);
    var valueWithoutErrors = value.filter(function (v) { return !v.error; }).map(function (v) { return v.src; });
    var dropzoneState = useDropzone({
        value: valueWithoutErrors,
        onDrop: function (acceptedFiles, rejectedFiles, event) {
            onChange(acceptedFiles.map(function (src) { return ({
                id: ulid(),
                src: src,
                name: src.name,
            }); }));
            onDrop && onDrop(acceptedFiles, rejectedFiles, event);
        },
        multiple: multiple,
        accept: accept,
        maxFileSize: maxFileSize,
        minFileSize: minFileSize,
        maxFileNumber: maxFileNumber + uploadedValue.length,
        disabled: disabled,
    });
    // copy and lift dropError to make it controlled
    React.useLayoutEffect(function () {
        onDropError(dropzoneState.dropError);
    }, [dropzoneState.dropError]);
    var dropErrorInternal = dropError || {
        message: '',
        title: '',
        type: 'RESET',
    };
    var _c = React.useState(0), errorBannerHeight = _c[0], setErrorBannerHeight = _c[1];
    var _d = React.useState(true), isErrorBannerCollapsed = _d[0], setIsErrorBannerCollapsed = _d[1];
    var itemsCount = value.length;
    var isErrorBannerShown = Boolean(dropErrorInternal.title || dropErrorInternal.message);
    var filesLimitForIcon = 5;
    var isIconVisible = itemsCount < filesLimitForIcon && isErrorBannerCollapsed;
    var getDropzoneHeight = function () {
        var errorBannerHeight = getErrorBannerHeight();
        var listHeight = getListHeight(false);
        return Math.max(uploaderHeight - listHeight - errorBannerHeight, dropzoneHeight);
    };
    var getErrorBannerHeight = function () {
        var errorBanner = errorBannerRef === null || errorBannerRef === void 0 ? void 0 : errorBannerRef.current;
        return errorBanner && isErrorBannerShown
            ? Math.floor(errorBanner.getBoundingClientRect().height) +
                errorBannerMarginTop +
                errorBannerMarginBottom
            : 0;
    };
    var getListHeight = function (clientHeight) {
        if (clientHeight === void 0) { clientHeight = true; }
        var maxListHeight = Math.min(itemsCount * defaultRowHeight, defaultListHeight);
        var listMarginsAndBorders = itemsCount
            ? listMarginTop + 2 * listBorderWidth
            : 0;
        var listHeight = itemsCount
            ? maxListHeight + (clientHeight ? 0 : listMarginsAndBorders)
            : 0;
        var minListHeight = (function (itemsCount) {
            switch (itemsCount) {
                case 0:
                    return 0;
                case 1:
                    return defaultRowHeight;
                default:
                    // Ensure that the list is scrollable
                    return (defaultRowHeight +
                        spareHeightForListAccountingErrorBannerMaxHeight);
            }
        })(itemsCount);
        return Math.max(listHeight - errorBannerHeight, minListHeight + (clientHeight ? 0 : listMarginsAndBorders));
    };
    var updateDropzoneHeight = function () {
        var _a;
        var dropzoneRootEl = (_a = dropzoneRootRef === null || dropzoneRootRef === void 0 ? void 0 : dropzoneRootRef.current) === null || _a === void 0 ? void 0 : _a.rootRef.current;
        if (dropzoneRootEl) {
            dropzoneRootEl.style.height = getDropzoneHeight() + 'px';
        }
    };
    var _e = React.useState(getListHeight()), listHeight = _e[0], setListHeight = _e[1];
    var setResizeObserverTarget = useResizeObserver(function () {
        var errorBannerHeight = getErrorBannerHeight();
        setErrorBannerHeight(errorBannerHeight);
        setIsErrorBannerCollapsed(errorBannerHeight < collapsedBannerThreshold);
    });
    React.useLayoutEffect(function () {
        var listHeight = getListHeight();
        setListHeight(listHeight);
        updateDropzoneHeight();
    }, [itemsCount, errorBannerHeight, isErrorBannerShown]);
    React.useEffect(function () {
        if (!isErrorBannerShown) {
            setErrorBannerHeight(0);
            setIsErrorBannerCollapsed(true);
        }
    }, [isErrorBannerShown]);
    return (React.createElement(StyledLocalSource, { ref: ref, "data-qa": qa === null || qa === void 0 ? void 0 : qa.dropzone },
        React.createElement(StyledDropzoneWrapper, __assign({}, dropzoneState, { isIconVisible: isIconVisible, contentRenderer: function (props) { return (React.createElement(React.Fragment, null,
                React.createElement(DefaultMessage, __assign({}, __assign(__assign({}, props), { multiple: multiple }))), dropzoneContentRenderer === null || dropzoneContentRenderer === void 0 ? void 0 :
                dropzoneContentRenderer(props))); }, rootProps: {
                style: { height: 'auto', transition: 'none' },
            }, ref: dropzoneRootRef })),
        React.createElement(StyledDropzoneErrorBanner, { error: dropErrorInternal, qa: {
                showErrorDetails: qa === null || qa === void 0 ? void 0 : qa.showErrorDetails,
                hideError: qa === null || qa === void 0 ? void 0 : qa.hideError,
            }, fileRejections: dropzoneState.fileRejections, onDismiss: function () { return dropzoneState.dispatchDropError(dropErrors.reset); }, ref: mergeRefs(errorBannerRef, setResizeObserverTarget) }),
        React.createElement(StyledThumbnailList, { items: value, onCancel: onCancel, listHeight: listHeight, rowHeight: defaultRowHeight })));
});
//# sourceMappingURL=LocalSource.js.map