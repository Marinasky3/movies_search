var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import React from 'react';
import { VariableSizeGrid } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';
import { mergeRefs } from '../../effects/mergeRefs';
import { useI18nContext } from '../../state/I18n';
import { Spinner } from '../Spinner';
import { Tooltip } from '../Tooltip';
import { useGridNavigation } from './ThumbnailGrid.hooks';
import { StyledGroupCell, StyledGroupTitle, StyledSpinnerWrapper, StyledThumbnail, StyledThumbnailGrid, } from './ThumbnailGrid.styles';
function noop() { }
var asyncNoop = function () { return Promise.resolve(); };
var titleHeight = 20;
var titleTopPadding = 24;
var thumbnailHeight = 138;
var thumbnailWidh = 104;
var columnsCount = 5;
var gutterSize = 12;
var columnWidth = thumbnailWidh + gutterSize;
var gridLeftPadding = 24;
var defaultGridWidth = gridLeftPadding + columnWidth * columnsCount;
var defaultGridHeight = (thumbnailHeight + gutterSize) * 3;
var getGridRows = function (_a) {
    var items = _a.items, groups = _a.groups, title = _a.title, _b = _a.isFetching, isFetching = _b === void 0 ? false : _b, groupTitleFallback = _a.groupTitleFallback;
    var splitToRows = function (items) {
        return items.reduce(function (acc, item, index) {
            var rowIndex = Math.floor(index / columnsCount);
            var row = (acc[rowIndex] = acc[rowIndex] || []);
            row.push(item);
            return acc;
        }, []);
    };
    var splitToGroupedRows = function (items, groups) {
        var groupedRows = [];
        var groupedThumbnails = items.reduce(function (acc, item) {
            var _a;
            var groupId = (_a = item.groupId) !== null && _a !== void 0 ? _a : String(item.groupId);
            var group = acc.get(groupId);
            if (group) {
                group.push(item);
            }
            else {
                acc.set(groupId, [item]);
            }
            return acc;
        }, new Map(groups.map(function (_a) {
            var id = _a.id;
            return [id, []];
        })));
        groupedThumbnails.forEach(function (group, groupId) {
            var _a;
            var groupRows = splitToRows(group);
            if (groupRows.length) {
                var groupTitleRow = [
                    {
                        title: ((_a = groups.find(function (_a) {
                            var id = _a.id;
                            return groupId === id;
                        })) === null || _a === void 0 ? void 0 : _a.title) ||
                            groupTitleFallback,
                    },
                ];
                groupRows.unshift(groupTitleRow);
            }
            groupedRows = __spreadArray(__spreadArray([], groupedRows, true), groupRows, true);
        });
        return groupedRows;
    };
    var setGridTitle = function (rows) {
        if (title) {
            rows.unshift([{ title: title }]);
        }
        return rows;
    };
    var setLoadingIndicator = function (rows) {
        if (isFetching) {
            rows.push([{ isFetching: isFetching }]);
        }
        return rows;
    };
    var gridRows = groups
        ? splitToGroupedRows(items, groups)
        : splitToRows(items);
    var gridRowsWithOptionalTitle = setGridTitle(gridRows);
    var gridRowsWithOptionalLoadingIndicator = setLoadingIndicator(gridRowsWithOptionalTitle);
    return gridRowsWithOptionalLoadingIndicator;
};
var GroupCell = function (_a) {
    var children = _a.children, style = _a.style, props = __rest(_a, ["children", "style"]);
    return (React.createElement(StyledGroupCell, __assign({ style: __assign(__assign({}, style), { left: (style === null || style === void 0 ? void 0 : style.left) + gridLeftPadding, top: (style === null || style === void 0 ? void 0 : style.top) + gutterSize, width: columnWidth * columnsCount }) }, props), children));
};
var ThumbnailCell = function (_a) {
    var children = _a.children, className = _a.className, style = _a.style, props = __rest(_a, ["children", "className", "style"]);
    return (React.createElement("div", __assign({ style: __assign(__assign({}, style), { left: (style === null || style === void 0 ? void 0 : style.left) + gridLeftPadding, top: (style === null || style === void 0 ? void 0 : style.top) + gutterSize }) }, props), children));
};
// See https://github.com/bvaughn/react-window/issues/130
var GridOuterContainer = React.forwardRef(function (props, ref) { return React.createElement("div", __assign({ ref: ref, tabIndex: -1 }, props)); });
var GridInnerContainer = React.forwardRef(function (_a, ref) {
    var style = _a.style, props = __rest(_a, ["style"]);
    return (React.createElement("div", __assign({ ref: ref, style: __assign(__assign({}, style), { paddingLeft: gridLeftPadding, width: (style === null || style === void 0 ? void 0 : style.width) + gridLeftPadding }) }, props)));
});
export var ThumbnailGrid = React.forwardRef(function (_a, forwardRef) {
    var items = _a.items, selected = _a.selected, groups = _a.groups, _b = _a.title, title = _b === void 0 ? '' : _b, _c = _a.gridWidth, gridWidth = _c === void 0 ? defaultGridWidth : _c, _d = _a.gridHeight, gridHeight = _d === void 0 ? defaultGridHeight : _d, _e = _a.onSelect, onSelect = _e === void 0 ? noop : _e, _f = _a.onDeselect, onDeselect = _f === void 0 ? noop : _f, _g = _a.disableSelection, disableSelection = _g === void 0 ? {
        value: false,
        tooltip: '',
    } : _g, _h = _a.isFetching, isFetching = _h === void 0 ? false : _h, _j = _a.loadMoreItems, loadMoreItems = _j === void 0 ? asyncNoop : _j, qa = _a.qa, props = __rest(_a, ["items", "selected", "groups", "title", "gridWidth", "gridHeight", "onSelect", "onDeselect", "disableSelection", "isFetching", "loadMoreItems", "qa"]);
    var gridContainerRef = React.useRef(null);
    var I18n = useI18nContext();
    var gridContainer = gridContainerRef.current;
    var gridRef = React.useRef(null);
    var gridInstance = gridRef.current;
    var rows = React.useMemo(function () {
        return getGridRows({
            items: items,
            groups: groups,
            isFetching: isFetching,
            title: title,
            groupTitleFallback: I18n.t('core.fileExplorer.ungroupedThumbnailGridGroup'),
        });
    }, [items, groups, title, isFetching]);
    var isTitleRow = function (rowCells) {
        return 'title' in rowCells[0];
    };
    var isFetchingRow = function (rowCells) {
        return 'isFetching' in rowCells[0];
    };
    var isNonNavigableRow = function (rowCells) {
        return isTitleRow(rowCells) || isFetchingRow(rowCells);
    };
    var rowHeights = React.useMemo(function () {
        return rows.map(function (rowCells, index) {
            var titleRow = isTitleRow(rowCells);
            var titleRowIsNotFirstGridRow = titleRow && index > 0;
            var rowPadding = (titleRowIsNotFirstGridRow ? titleTopPadding : 0) + gutterSize;
            if (titleRow) {
                return titleHeight + rowPadding;
            }
            else {
                return thumbnailHeight + rowPadding;
            }
        });
    }, [rows]);
    var nonNavigableRowIndices = React.useMemo(function () {
        return rows
            .map(function (rowCells, index) { return ({
            index: index,
            isNonNavigableRow: isNonNavigableRow(rowCells),
        }); })
            .filter(function (_a) {
            var isNonNavigableRow = _a.isNonNavigableRow;
            return isNonNavigableRow;
        })
            .map(function (_a) {
            var index = _a.index;
            return index;
        });
    }, [rows]);
    var navigationIndicesRows = React.useMemo(function () {
        return rows
            .filter(function (rowCells) { return !isNonNavigableRow(rowCells); })
            .map(function (rowCells) {
            return rowCells.map(function (cell) {
                return items.findIndex(function (item) { return item.id === cell.id; });
            });
        });
    }, [rows, items]);
    var getNumberOfNonNavigableRowsBefore = React.useCallback(function (rowIndex) {
        return nonNavigableRowIndices.filter(function (index) { return rowIndex > index; }).length;
    }, [nonNavigableRowIndices]);
    var getThumbnailNavigationIndex = React.useCallback(function (rowIndex, cellIndex) {
        return navigationIndicesRows[rowIndex - getNumberOfNonNavigableRowsBefore(rowIndex)][cellIndex];
    }, [navigationIndicesRows, getNumberOfNonNavigableRowsBefore]);
    var thumbnailNavigationIndexToRowIndexMap = React.useMemo(function () {
        return rows.reduce(function (acc, rowCells, rowIndex) {
            if (isNonNavigableRow(rowCells))
                return acc;
            var mappedRowCells = rowCells.reduce(function (acc, _, cellIndex) {
                var navIndex = String(getThumbnailNavigationIndex(rowIndex, cellIndex));
                acc[navIndex] = rowIndex;
                return acc;
            }, {});
            return __assign(__assign({}, acc), mappedRowCells);
        }, {});
    }, [rows, getThumbnailNavigationIndex]);
    var _k = React.useState(false), isGridFocused = _k[0], setIsGridFocused = _k[1];
    var navigation = useGridNavigation({
        indicesRows: navigationIndicesRows,
    });
    var isThumbnailSelected = function (thumbnail) {
        return selected.map(function (_a) {
            var id = _a.id;
            return id;
        }).includes(thumbnail.id);
    };
    var toggle = function (thumbnail) {
        if (isThumbnailSelected(thumbnail)) {
            onDeselect(thumbnail);
        }
        else if (!disableSelection.value) {
            onSelect(thumbnail);
        }
    };
    var onMouseDown = function (e) {
        e.preventDefault();
        var focusedEl = document.activeElement;
        if (focusedEl && focusedEl !== gridContainer) {
            focusedEl.blur();
        }
    };
    var updateNavigationPosition = function (e) {
        switch (e.key) {
            case 'ArrowDown':
            case 'Down':
                e.preventDefault();
                return navigation.down(e);
            case 'ArrowUp':
            case 'Up':
                e.preventDefault();
                return navigation.up(e);
            case 'ArrowLeft':
            case 'Left':
                e.preventDefault();
                return navigation.left(e);
            case 'ArrowRight':
            case 'Right':
                e.preventDefault();
                return navigation.right(e);
            default:
                return -1;
        }
    };
    var onKeyDown = function (e) {
        if (!isGridFocused)
            return;
        if (e.key === 'Enter') {
            e.preventDefault();
            toggle(items[navigation.index]);
        }
        else {
            var newPosition = updateNavigationPosition(e);
            if (newPosition !== -1) {
                gridInstance === null || gridInstance === void 0 ? void 0 : gridInstance.scrollToItem({
                    rowIndex: thumbnailNavigationIndexToRowIndexMap[newPosition],
                });
            }
        }
    };
    React.useEffect(function () {
        navigation.setIndicesRows(navigationIndicesRows);
    }, [navigationIndicesRows, navigation]);
    React.useEffect(function () {
        // VariableSizeGrid caches offsets and measurements for each row index for performance purposes.
        // Method below clears cached data and triggers recalucation when a new value of search filter recomposites grid structure.
        gridInstance === null || gridInstance === void 0 ? void 0 : gridInstance.resetAfterRowIndex(0);
    }, [items, gridInstance]);
    return (React.createElement(StyledThumbnailGrid, __assign({}, props, { ref: mergeRefs(forwardRef, gridContainerRef), "data-qa": qa === null || qa === void 0 ? void 0 : qa.grid, tabIndex: 0, onBlur: function () { return setIsGridFocused(false); }, onFocus: function () { return setIsGridFocused(true); }, onKeyDown: onKeyDown, onMouseDown: onMouseDown }),
        React.createElement(InfiniteLoader, { loadMoreItems: isFetching ? asyncNoop : loadMoreItems, itemCount: rows.length, isItemLoaded: function (index) { return index < rows.length - 1; }, threshold: 0 }, function (_a) {
            var onItemsRendered = _a.onItemsRendered, infiniteLoaderRef = _a.ref;
            return (React.createElement(VariableSizeGrid, { width: gridWidth, height: gridHeight, rowCount: rows.length, rowHeight: function (index) { return rowHeights[index]; }, columnCount: columnsCount, columnWidth: function () { return columnWidth; }, innerElementType: GridInnerContainer, outerElementType: GridOuterContainer, overscanRowCount: 2, onItemsRendered: function (_a) {
                    var visibleRowStartIndex = _a.visibleRowStartIndex, visibleRowStopIndex = _a.visibleRowStopIndex, overscanRowStopIndex = _a.overscanRowStopIndex, overscanRowStartIndex = _a.overscanRowStartIndex;
                    onItemsRendered({
                        overscanStartIndex: overscanRowStartIndex,
                        overscanStopIndex: overscanRowStopIndex,
                        visibleStartIndex: visibleRowStartIndex,
                        visibleStopIndex: visibleRowStopIndex,
                    });
                }, ref: mergeRefs(gridRef, infiniteLoaderRef) }, function (_a) {
                var _b;
                var columnIndex = _a.columnIndex, rowIndex = _a.rowIndex, style = _a.style;
                var cellData = rows[rowIndex][columnIndex];
                if (!cellData)
                    return null;
                if ('title' in cellData)
                    return (React.createElement(GroupCell, { style: style },
                        React.createElement(StyledGroupTitle, { weight: "bold", color: "gray15" }, cellData.title)));
                if ('isFetching' in cellData) {
                    return (React.createElement(GroupCell, { style: style },
                        React.createElement(StyledSpinnerWrapper, null,
                            React.createElement(Spinner, null))));
                }
                var thumbnailNavigationIndex = getThumbnailNavigationIndex(rowIndex, columnIndex);
                var isNavigationTarget = navigation.index === thumbnailNavigationIndex;
                var isFocused = isGridFocused && isNavigationTarget;
                var isSelected = isThumbnailSelected(cellData);
                var isDisabled = disableSelection.value && !isSelected;
                return (React.createElement(ThumbnailCell, { style: style },
                    React.createElement(Tooltip, { key: cellData.id, trigger: isDisabled ? 'hover' : 'none', overlay: disableSelection.tooltip, showKeys: [] },
                        React.createElement(StyledThumbnail, { "data-thumbnail": true, "data-qa": (_b = qa === null || qa === void 0 ? void 0 : qa.thumbnail) === null || _b === void 0 ? void 0 : _b.call(qa, cellData.id), focused: isFocused, selected: isSelected, disabled: isDisabled, caption: cellData.name, src: cellData.src, label: cellData.label, hasCaptionPlaceholder: true, onClick: function (_a) {
                                var _b;
                                var target = _a.target;
                                var isCaptionTooltipClick = (_b = target
                                    .dataset) === null || _b === void 0 ? void 0 : _b.captionTooltip;
                                if (isCaptionTooltipClick)
                                    return;
                                navigation.setIndex(thumbnailNavigationIndex);
                                toggle(cellData);
                                gridContainer === null || gridContainer === void 0 ? void 0 : gridContainer.focus();
                            } }))));
            }));
        })));
});
//# sourceMappingURL=ThumbnailGrid.js.map