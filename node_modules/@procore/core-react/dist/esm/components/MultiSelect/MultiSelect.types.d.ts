import { MenuProps, MenuRef, Selection } from '../MenuImperative/MenuImperative.types';
import { OverlayTriggerProps } from '../OverlayTrigger';
import { DropdownPlacement } from '../Dropdown/Dropdown.types';
export declare type ChangeEvent = React.ChangeEvent<HTMLInputElement>;
export declare type OptionItem = any;
export interface OptionProps {
    children?: React.ReactNode;
    className?: string;
    selected?: boolean;
    suggested?: boolean;
    disabled?: boolean;
    value: OptionItem;
}
export interface OptionRendererProps extends OptionProps {
    getId: MultiSelectConfig['getId'];
    getLabel: MultiSelectConfig['getLabel'];
    qa: QaTags;
}
export interface GroupItem {
    id: string;
    label: string;
}
export interface GroupHeader extends GroupItem {
    isGroupHeader: boolean;
}
export interface MultiSelectConfig {
    getGroup: (option: OptionItem) => number | string;
    getId: (option: OptionItem) => number | string;
    getLabel: (option: OptionItem) => string;
    menuRef: React.RefObject<MenuRef>;
    onChange?: (value: OptionItem[], event?: Event) => void;
    onSearch?: (e: ChangeEvent) => void;
    onSelect?: (selection: Selection) => void;
    optgroups?: GroupItem[];
    options: OptionItem[];
    value: OptionItem[];
}
export interface MultiSelectHook {
    ids: Set<number | string>;
    index: number | null;
    menuRef: React.RefObject<MenuRef>;
    options: (OptionItem | GroupHeader)[];
    search: string;
    clearToken: () => void;
    decrementToken: () => void;
    incrementToken: () => void;
    onSearch: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onSelect: (selection: Selection) => void;
    removeToken: (index: number) => void;
    domHandlers: {
        onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void;
    };
}
export interface GroupedOptionsProps {
    multiselect: MultiSelectHook;
    groupHeaderRenderer: (group: GroupItem) => React.ReactNode;
    optionRenderer: (option: OptionItem, props: OptionRendererProps) => React.ReactNode;
    getId: MultiSelectConfig['getId'];
    getLabel: MultiSelectConfig['getLabel'];
    isOptionDisabled: (option: OptionItem) => boolean;
    qa: QaTags;
}
export interface QaTags {
    option?: (option: OptionItem) => string;
    token?: (option: OptionItem) => string;
    tokenClear?: (option: OptionItem) => string;
}
export interface TokenRendererProps {
    focused: boolean;
    disabled: boolean;
    option: OptionItem;
    removeToken: () => void;
    getLabel: (opt: OptionItem) => React.ReactNode;
    qa: QaTags;
}
export interface MultiSelectProps {
    afterHide?: OverlayTriggerProps['afterHide'];
    afterShow?: OverlayTriggerProps['afterShow'];
    beforeHide?: OverlayTriggerProps['beforeHide'];
    beforeShow?: OverlayTriggerProps['beforeShow'];
    /**
     * Callback for each entry in <Code>options</Code> to define relation to
     * group in <Code>groups</Code>
     * <CodeBlock>{'(option: OptionItem) => React.ReactNode'}</CodeBlock>
     */
    getGroup?: MultiSelectConfig['getGroup'];
    /**
     * Callback for each entry in <Code>options</Code> for keying and
     * optimizations
     * <CodeBlock>{'(option: OptionItem) => number | string'}</CodeBlock>*
     */
    getId?: MultiSelectConfig['getId'];
    /**
     * Callback for each entry in <Code>options</Code> to generate the token
     * label.
     * <CodeBlock>{'(option: OptionItem) => string'}</CodeBlock>
     */
    getLabel?: MultiSelectConfig['getLabel'];
    /**
     * Callback for when a user types into the multiselect input
     <CodeBlock>{'(event: KeyboardEvent) => void'}</CodeBlock>
     */
    onSearch?: MultiSelectConfig['onSearch'];
    /**
     * Array of available option groups
     */
    optgroups?: MultiSelectConfig['optgroups'];
    /**
     * Array of available options
     */
    options?: MultiSelectConfig['options'];
    onScrollBottom?: MenuProps['onScrollBottom'];
    block?: boolean;
    className?: string;
    disabled?: boolean;
    isOptionDisabled?: (option: OptionItem) => boolean;
    emptyMessage?: string;
    error?: boolean;
    /**
     * Callback for rendering header for each entry in <Code>groups</Code>
     * <CodeBlock>{'(group: GroupItem) => React.ReactNode'}</CodeBlock>
     */
    groupHeaderRenderer?: (group: GroupItem) => React.ReactNode;
    loading?: boolean;
    onBlur?: React.SelectHTMLAttributes<HTMLDivElement>['onBlur'];
    onChange?: (value: OptionItem[], event?: Event) => void;
    onFocus?: React.SelectHTMLAttributes<HTMLDivElement>['onFocus'];
    optionRenderer?: (option: OptionItem) => React.ReactNode;
    placeholder?: string;
    placement?: DropdownPlacement;
    qa?: QaTags;
    tabIndex?: number;
    /**
     * Callback for rendering each selected value
     * <CodeBlock>
     *  {'(props: TokenRendererProps) => React.ReactNode'}
     * </CodeBlock>
     */
    tokenRenderer?: (props: TokenRendererProps) => React.ReactNode;
    /**
     * Array of the currently selected values
     */
    value?: OptionItem[];
}
