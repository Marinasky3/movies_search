var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import Button from '../Button';
import OverlayTrigger from '../OverlayTrigger';
import { TieredSelectMenu } from '../TieredSelect/TieredSelectMenu';
import { TieredSelectContext } from '../TieredSelect/TieredSelect';
import { useSearch } from './useSearch';
import { always, defaultGetGroupId, defaultGetId, defaultGetLabel, defaultGetNextGroupId, defaultIsTierDisabled, empty, findPath, getPathKey, hideKeys, noop, } from './TieredDropdown.helpers';
var TieredDropdownInternal = React.forwardRef(function TieredDropdownInternal(_a, ref) {
    var className = _a.className, _b = _a.disabled, disabled = _b === void 0 ? false : _b, _c = _a.loading, loading = _c === void 0 ? false : _c, onKeyDown = _a.onKeyDown, _d = _a.options, options = _d === void 0 ? empty : _d, _e = _a.value, value = _e === void 0 ? empty : _e, style = _a.style, props = __rest(_a, ["className", "disabled", "loading", "onKeyDown", "options", "value", "style"]);
    var _f = React.useContext(TieredSelectContext), afterHide = _f.afterHide, afterShow = _f.afterShow, beforeHide = _f.beforeHide, beforeShow = _f.beforeShow, block = _f.block, getLabel = _f.getLabel, getGroupId = _f.getGroupId, getNextGroupId = _f.getNextGroupId, isLeaf = _f.isLeaf, onChange = _f.onChange, onNavigate = _f.onNavigate, onSearch = _f.onSearch, tabIndex = _f.tabIndex;
    var searchablePaths = React.useMemo(function () {
        if (onSearch) {
            return [];
        }
        var paths = [];
        var optionsByNextGroupId = options.reduce(function (map, option) {
            var _a;
            var nextGroupId = getNextGroupId(option);
            if (nextGroupId) {
                return __assign(__assign({}, map), (_a = {}, _a[nextGroupId] = option, _a));
            }
            return map;
        }, {});
        options.forEach(function (item) {
            if (!getNextGroupId(item)) {
                var path = findPath(optionsByNextGroupId, item, getGroupId);
                var pathKey = getPathKey(path, getLabel);
                paths.push({
                    path: path,
                    pathKey: pathKey,
                    label: pathKey,
                    node: item,
                });
            }
        });
        return paths;
    }, [getGroupId, getLabel, getNextGroupId, onSearch, options]);
    var _g = useSearch({
        items: searchablePaths,
        keysToSearch: ['pathKey'],
    }), searchTerm = _g.searchTerm, filteredItems = _g.filteredItems, setSearch = _g.setSearch;
    var menuOptions = React.useMemo(function () {
        return searchTerm.length > 0 ? filteredItems : options;
    }, [filteredItems, options, searchTerm.length]);
    var tieredSelectMenuRef = React.useRef(null);
    var _h = React.useState(null), currentTier = _h[0], setCurrentTier = _h[1];
    // internal value used for navigation
    var _j = React.useState(value), internalValue = _j[0], setInternalValue = _j[1];
    var internalOnNavigate = React.useCallback(function (nextGroupId, value) {
        setInternalValue(value);
        setCurrentTier(nextGroupId);
        onNavigate === null || onNavigate === void 0 ? void 0 : onNavigate(nextGroupId, value);
    }, [onNavigate]);
    var internalOnSearch = React.useCallback(function (event) {
        if (onSearch === undefined) {
            setSearch(event.target.value);
        }
        else {
            onSearch(event);
        }
    }, [onSearch, setSearch]);
    /**
     * Emulates on select
     */
    var internalOnChange = React.useCallback(function (selection) {
        if (searchTerm.length > 0) {
            onChange === null || onChange === void 0 ? void 0 : onChange(__assign(__assign({}, selection), { value: selection.item.path, item: selection.item.node }));
        }
        else {
            onChange === null || onChange === void 0 ? void 0 : onChange(selection);
        }
    }, [onChange, searchTerm]);
    /**
     * Used to reset state after selection
     */
    var internalAfterHide = React.useCallback(function () {
        setCurrentTier(null);
        setInternalValue([]);
        afterHide && afterHide();
    }, [afterHide]);
    // if value prop changes, update value state, current tier, and set button label
    // else open to root
    React.useEffect(function () {
        if (value.length > 0) {
            var lastEntryInValue = value[value.length - 1];
            setInternalValue(value);
            // show children of last tier in value if not a leaf node
            // otherwise we want to show the parent of the last tier in value
            if (isLeaf && !isLeaf(lastEntryInValue)) {
                setCurrentTier(getNextGroupId(lastEntryInValue));
            }
            else {
                setCurrentTier(getGroupId(lastEntryInValue) || null);
            }
        }
        else {
            setCurrentTier(null);
            setInternalValue([]);
        }
    }, [getGroupId, getNextGroupId, isLeaf, value]);
    return (React.createElement(OverlayTrigger, { afterHide: internalAfterHide, afterShow: afterShow, beforeHide: beforeHide, beforeShow: function (e) {
            return beforeShow && beforeShow(e);
        }, canFlip: true, hideKeys: hideKeys, overlay: disabled ? null : (React.createElement(TieredSelectMenu, __assign({ currentTier: currentTier, options: menuOptions, loading: loading, menuRef: tieredSelectMenuRef, onNavigate: internalOnNavigate, onSearch: internalOnSearch, onChange: internalOnChange, value: internalValue, previousValue: [] }, props))), placement: "bottom-left", ref: ref, trigger: "click" },
        React.createElement(Button, { "data-qa": props['data-qa'], block: block, className: className, disabled: disabled, icon: props.icon, iconRight: props.iconRight, loading: loading, size: props.size, style: style, tabIndex: tabIndex, variant: props.variant }, props.children)));
});
export var TieredDropdown = React.forwardRef(function TieredDropdown(_a, ref) {
    var _b = _a.afterHide, afterHide = _b === void 0 ? noop : _b, _c = _a.afterShow, afterShow = _c === void 0 ? noop : _c, _d = _a.beforeHide, beforeHide = _d === void 0 ? always : _d, _e = _a.beforeShow, beforeShow = _e === void 0 ? always : _e, block = _a.block, _f = _a.getGroupId, getGroupId = _f === void 0 ? defaultGetGroupId : _f, _g = _a.getId, getId = _g === void 0 ? defaultGetId : _g, _h = _a.getLabel, getLabel = _h === void 0 ? defaultGetLabel : _h, _j = _a.getNextGroupId, getNextGroupId = _j === void 0 ? defaultGetNextGroupId : _j, _k = _a.i18nScope, i18nScope = _k === void 0 ? 'core.tieredDropdown' : _k, _l = _a.isTierDisabled, isTierDisabled = _l === void 0 ? defaultIsTierDisabled : _l, _m = _a.onSelect, onSelect = _m === void 0 ? noop : _m, onNavigate = _a.onNavigate, onScrollBottom = _a.onScrollBottom, onSearch = _a.onSearch, tabIndex = _a.tabIndex, props = __rest(_a, ["afterHide", "afterShow", "beforeHide", "beforeShow", "block", "getGroupId", "getId", "getLabel", "getNextGroupId", "i18nScope", "isTierDisabled", "onSelect", "onNavigate", "onScrollBottom", "onSearch", "tabIndex"]);
    var isLeaf = React.useCallback(function (tier) {
        return !getNextGroupId(tier);
    }, [getNextGroupId]);
    return (React.createElement(TieredSelectContext.Provider, { value: {
            afterHide: afterHide,
            afterShow: afterShow,
            beforeHide: beforeHide,
            beforeShow: beforeShow,
            block: block,
            getGroupId: getGroupId,
            getId: getId,
            getLabel: getLabel,
            getNextGroupId: getNextGroupId,
            getValueString: function () { return ''; },
            i18nScope: i18nScope,
            isTierDisabled: isTierDisabled,
            isLeaf: isLeaf,
            onChange: onSelect,
            onNavigate: onNavigate,
            onScrollBottom: onScrollBottom,
            onSearch: onSearch,
            tabIndex: tabIndex,
        } },
        React.createElement(TieredDropdownInternal, __assign({ ref: ref }, props, { value: [] }))));
});
export default TieredDropdown;
//# sourceMappingURL=TieredDropdown.js.map