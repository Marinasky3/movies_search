var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { isValidElement, useEffect, useMemo, useState } from 'react';
import { useI18nContext } from '../../state/I18n';
import { addSubcomponents } from '../../utils/addSubcomponents';
import Checkbox from '../Checkbox';
import { Search as SearchBase } from '../Search';
import { StyledDroppable, StyledFooter, StyledGrip, StyledGroup, StyledHeader, StyledItem, StyledWrapper, StyledMenu, StyledOptions, StyledSearch, } from './MenuImperative.styles';
import { DragDropContext, Droppable as DndDroppable, Draggable, useMouseSensor, useTouchSensor, } from 'react-beautiful-dnd';
import { Grip } from '@procore/core-icons/dist';
import { colors } from '../../styles/colors';
import { mergeRefs } from '../../effects/mergeRefs';
import { useZIndexContext } from '../../state/ZIndex';
import { createSensors } from './sensors';
var onScrollBottomThreshold = 8;
var NO_ANNOUCEMENT = '';
function noop() { }
function isScrolledToBottom(e) {
    return (e.currentTarget instanceof HTMLElement &&
        e.currentTarget.scrollTop >=
            e.currentTarget.scrollHeight -
                e.currentTarget.clientHeight -
                onScrollBottomThreshold);
}
// TODO use the shared mergeRefs utility
export function useMergeRef(externalRef) {
    var ref = React.useRef();
    return [
        ref,
        React.useCallback(function (node) {
            ref.current = node;
            if (externalRef) {
                if (typeof externalRef === 'function') {
                    externalRef(node);
                }
                else {
                    externalRef.current = node;
                }
            }
        }, [externalRef]),
    ];
}
var MenuContext = React.createContext({
    currentlyDroppableIn: [],
    onHoverItem: noop,
    onScrollBottom: noop,
    onSelect: noop,
});
export function useMenuContext() {
    var context = React.useContext(MenuContext);
    if (context === null) {
        throw new Error('Cannot find `Menu` context, please wrap your component in `<MenuContext.Provider>`');
    }
    return context;
}
var MenuImperative_ = React.forwardRef(function Menu(_a, forwardRef) {
    var _b = _a.circular, circular = _b === void 0 ? false : _b, _c = _a.onDragEnd, onDragEnd_ = _c === void 0 ? noop : _c, _d = _a.onScrollBottom, onScrollBottom_ = _d === void 0 ? noop : _d, _e = _a.onSelect, onSelect_ = _e === void 0 ? noop : _e, props = __rest(_a, ["circular", "onDragEnd", "onScrollBottom", "onSelect"]);
    var ref = React.useRef(null);
    var _f = useState([]), currentlyDroppableIn = _f[0], setCurrentlyDroppableIn = _f[1];
    // for context, used by Menu.Item
    var onSelect = React.useCallback(function (selection) {
        onSelect_(selection);
    }, [onSelect_]);
    var _g = useMemo(function () { return createSensors(ref, circular); }, [circular]), handleItemHover = _g.handleItemHover, handleKeyDown = _g.handleKeyDown, highlight = _g.highlight, highlighted = _g.highlighted, highlightFirst = _g.highlightFirst, highlightLast = _g.highlightLast, highlightSelected = _g.highlightSelected, highlightSuggested = _g.highlightSuggested, rehighlightCurrent = _g.rehighlightCurrent, prev = _g.prev, next = _g.next, select = _g.select, updateSelectCallback = _g.updateSelectCallback, useKeyboardSensor = _g.useKeyboardSensor;
    updateSelectCallback(onSelect);
    // exposes internal menu API
    React.useImperativeHandle(forwardRef, function () { return ({
        el: ref.current,
        highlight: highlight,
        highlighted: highlighted,
        highlightFirst: highlightFirst,
        highlightLast: highlightLast,
        highlightSelected: highlightSelected,
        highlightSuggested: highlightSuggested,
        next: next,
        prev: prev,
        select: select,
    }); });
    useEffect(rehighlightCurrent);
    function onDragStart(start, provided) {
        // TODO Replace with localized instructions
        provided.announce(NO_ANNOUCEMENT);
        var itemInfo = JSON.parse(start.draggableId);
        setCurrentlyDroppableIn(itemInfo.droppableIn);
    }
    function onDragUpdate(_update, provided) {
        // TODO Replace with localized instructions
        provided.announce(NO_ANNOUCEMENT);
    }
    var onDragEnd = React.useCallback(function (result, provided) {
        // TODO Replace with localized instructions
        provided.announce(NO_ANNOUCEMENT);
        setCurrentlyDroppableIn([]);
        if (result.reason === 'DROP' && result.destination) {
            var itemInfo = JSON.parse(result.draggableId);
            onDragEnd_({
                draggableId: itemInfo.draggableId,
                source: result.source,
                destination: result.destination,
            });
        }
    }, [onDragEnd_]);
    // for context, used by Menu.Options
    var onScrollBottom = React.useCallback(function (e) {
        if (isScrolledToBottom(e)) {
            onScrollBottom_(e);
        }
    }, [onScrollBottom_]);
    return (React.createElement(MenuContext.Provider, { value: {
            currentlyDroppableIn: currentlyDroppableIn,
            onHoverItem: handleItemHover,
            onScrollBottom: onScrollBottom,
            onSelect: onSelect,
        } },
        React.createElement(StyledWrapper, { ref: ref, onKeyDown: handleKeyDown, tabIndex: 0 },
            React.createElement(DragDropContext, { onDragStart: onDragStart, onDragUpdate: onDragUpdate, onDragEnd: onDragEnd, enableDefaultSensors: false, sensors: [useMouseSensor, useTouchSensor, useKeyboardSensor] },
                React.createElement(StyledMenu, __assign({}, props))))));
});
export var Group = React.forwardRef(function Group(_a, ref) {
    var clickable = _a.clickable, _b = _a.item, item = _b === void 0 ? 'group' : _b, props = __rest(_a, ["clickable", "item"]);
    return (React.createElement(StyledGroup, __assign({ ref: ref, onClick: function (e) {
            // TODO: implement selecting groups?
        }, "data-group": true, "data-value": JSON.stringify(item) }, props)));
});
function findDraggableRecursively(children, draggableId) {
    var nodeChildren = React.Children.toArray(children);
    for (var i = 0; i < nodeChildren.length; i++) {
        var child = nodeChildren[i];
        if (isValidElement(child)) {
            if ('draggableId' in child.props) {
                if (child.props.draggableId === draggableId) {
                    return child;
                }
            }
            else {
                var matchingChild = findDraggableRecursively(child.props.children, draggableId);
                if (matchingChild) {
                    return matchingChild;
                }
            }
        }
    }
    return null;
}
export function Droppable(_a) {
    var id = _a.id, children = _a.children;
    var ctx = useMenuContext();
    var cloneZIndex = useZIndexContext().value;
    function renderItemClone(provided, _snapshot, rubric) {
        var _a;
        var draggableInfo = JSON.parse(rubric.draggableId);
        var draggingChild = findDraggableRecursively(children, draggableInfo.draggableId);
        var cloneProps = (_a = draggingChild === null || draggingChild === void 0 ? void 0 : draggingChild.props) !== null && _a !== void 0 ? _a : {};
        return (React.createElement(ClonedItem, __assign({ hasCheckbox: (draggingChild === null || draggingChild === void 0 ? void 0 : draggingChild.type) === CheckboxItem, provided: provided, cloneZIndex: cloneZIndex }, cloneProps)));
    }
    return (React.createElement(DndDroppable, { droppableId: id, isDropDisabled: !ctx.currentlyDroppableIn.includes(id), renderClone: renderItemClone }, function (provided, snapshot) { return (React.createElement(StyledDroppable, { ref: provided.innerRef, "data-droppable": true },
        children,
        provided.placeholder)); }));
}
// creates a version of a draggable item that can be positioned correctly within modals
// this should always have the same appearance of an Item or CheckboxItem, but doesn't
// need to handle selection events, which can't be done while the item is being dragged
var ClonedItem = function (_a) {
    var _b = _a.hasCheckbox, hasCheckbox = _b === void 0 ? false : _b, _c = _a.children, children = _c === void 0 ? null : _c, _d = _a.selected, selected = _d === void 0 ? false : _d, provided = _a.provided, props = __rest(_a, ["hasCheckbox", "children", "selected", "provided"]);
    var itemProps = __assign(__assign({}, props), { $selected: selected });
    var itemChildren = hasCheckbox ? (React.createElement(Checkbox, { indeterminate: props.indeterminate, error: props.error, checked: selected, onChange: noop }, children)) : (children);
    return (React.createElement(StyledItem, __assign({ ref: provided.innerRef }, provided.draggableProps, provided.dragHandleProps, itemProps, { "$isDraggable": true, "$isDragging": true, style: __assign(__assign(__assign({}, provided.draggableProps.style), props.style), { zIndex: props.cloneZIndex }) }),
        React.createElement(StyledGrip, null,
            React.createElement(Grip, { color: colors.gray45 })),
        itemChildren));
};
export var Item = React.forwardRef(function Item(_a, forwardRef) {
    var _b = _a.children, children = _b === void 0 ? null : _b, _c = _a.item, item = _c === void 0 ? null : _c, _d = _a.onClick, onClick_ = _d === void 0 ? noop : _d, _e = _a.selected, selected = _e === void 0 ? false : _e, _f = _a.suggested, suggested = _f === void 0 ? false : _f, _g = _a.disabled, disabled = _g === void 0 ? false : _g, props = __rest(_a, ["children", "item", "onClick", "selected", "suggested", "disabled"]);
    var _h = useMergeRef(forwardRef), ref = _h[0], setRef = _h[1];
    var ctx = useMenuContext();
    var onClick = React.useCallback(function (event) {
        if (disabled)
            return;
        onClick_(event);
        ctx.onSelect({
            item: item,
            event: event,
            group: false,
            action: selected ? 'unselected' : 'selected',
        });
    }, [ctx, item, onClick_, disabled, selected]);
    var itemProps = __assign(__assign({}, props), { onClick: onClick, onMouseMove: function (e) { return ctx.onHoverItem(e.currentTarget); }, 'data-group': false, 'data-value': JSON.stringify(item), 'data-selected': selected, 'data-suggested': suggested, 'data-disabled': disabled, $disabled: disabled, $selected: selected });
    if ('droppableIn' in props &&
        'draggableId' in props &&
        'draggableIndex' in props) {
        // encoding id and valid droppables as the draggableId, so we can use them to determine where this item can be dropped
        var droppableInfo = {
            draggableId: props.draggableId,
            droppableIn: Array.isArray(props.droppableIn)
                ? props.droppableIn
                : [props.droppableIn],
        };
        return (React.createElement(Draggable, { draggableId: JSON.stringify(droppableInfo), index: props.draggableIndex, isDragDisabled: disabled }, function (provided) { return (React.createElement(StyledItem, __assign({ ref: mergeRefs(provided.innerRef, setRef) }, provided.draggableProps, provided.dragHandleProps, itemProps, { "$isDraggable": !disabled, style: __assign(__assign({}, provided.draggableProps.style), itemProps.style), tabIndex: -1 }),
            !disabled && (React.createElement(StyledGrip, null,
                React.createElement(Grip, { color: colors.gray45 }))),
            children)); }));
    }
    return (React.createElement(StyledItem, __assign({ ref: setRef }, itemProps), children));
});
export var CheckboxItem = React.forwardRef(function CheckboxItem(_a, forwardRef) {
    var _b = _a.selected, selected = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.error, error = _d === void 0 ? false : _d, _e = _a.indeterminate, indeterminate = _e === void 0 ? false : _e, _f = _a.children, children = _f === void 0 ? null : _f, props = __rest(_a, ["selected", "disabled", "error", "indeterminate", "children"]);
    function onCheckboxClick(event) {
        event.stopPropagation();
    }
    return (React.createElement(Item, __assign({}, props, { selected: selected, disabled: disabled, ref: forwardRef }),
        React.createElement(Checkbox, { indeterminate: indeterminate, error: error, disabled: disabled, checked: selected, onClick: onCheckboxClick, onChange: noop, tabIndex: -1 }, children)));
});
export var Options = React.forwardRef(function Options(props, ref) {
    var ctx = useMenuContext();
    return (React.createElement(StyledOptions, __assign({}, props, { ref: ref, onScroll: ctx.onScrollBottom, tabIndex: 0 })));
});
// TODO change this component to render out a Typeahead instead of
// the deprecated Search with typeahead prop
export var Search = function (_a) {
    var className = _a.className, _b = _a.i18nScope, i18nScope = _b === void 0 ? 'core.menu' : _b, placeholder = _a.placeholder, props = __rest(_a, ["className", "i18nScope", "placeholder"]);
    var I18n = useI18nContext();
    return (React.createElement(StyledSearch, { className: className },
        React.createElement(SearchBase, __assign({}, props, { autoFocus: true, placeholder: placeholder || I18n.t('search', { scope: i18nScope }), typeahead: true }))));
};
export var Header = React.forwardRef(function Header(_a, ref) {
    var props = __rest(_a, []);
    return React.createElement(StyledHeader, __assign({ ref: ref }, props));
});
export var Footer = React.forwardRef(function Footer(_a, ref) {
    var _b = _a.padding, padding = _b === void 0 ? 'md lg' : _b, props = __rest(_a, ["padding"]);
    return React.createElement(StyledFooter, __assign({ ref: ref, padding: padding }, props));
});
MenuImperative_.displayName = 'Menu';
Droppable.displayName = 'Menu.Droppable';
Footer.displayName = 'Menu.Footer';
Group.displayName = 'Menu.Group';
Header.displayName = 'Menu.Header';
Item.displayName = 'Menu.Item';
Options.displayName = 'Menu.Options';
Search.displayName = 'Menu.Search';
export var MenuImperative = addSubcomponents({
    CheckboxItem: CheckboxItem,
    Droppable: Droppable,
    Footer: Footer,
    Group: Group,
    Header: Header,
    Item: Item,
    Options: Options,
    Search: Search,
}, MenuImperative_);
//# sourceMappingURL=MenuImperative.js.map