var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { ChevronRight, Help, Home, Plus } from '@procore/core-icons/dist';
import React from 'react';
import { Box } from '../../layouts/Box';
import { FlexList } from '../../layouts/FlexList';
import { useI18nContext } from '../../state/I18n';
import { Breadcrumbs } from '../Breadcrumbs';
import { Button } from '../Button';
import { Input } from '../Input';
import { MenuImperative } from '../MenuImperative';
import { CloseOnFocus, useOverlayTriggerContext } from '../OverlayTrigger';
import Spinner from '../Spinner';
import Tooltip from '../Tooltip';
import { Typography } from '../Typography/Typography';
import { TieredSelectContext, useHighlightItemEffects } from './TieredSelect';
import { StyledTieredSelect, StyledTieredSelectBreadcrumbs, StyledTieredSelectHome, StyledTieredSelectIcon, StyledTieredSelectLoadingMore, StyledTieredSelectOption, StyledTieredSelectOverlay, StyledTieredSelectSpinnerOverlay, } from './TieredSelect.styles';
function ArrowButton(props) {
    return (React.createElement(StyledTieredSelectIcon, { alignItems: "center", justifyContent: "center" },
        React.createElement(ChevronRight, null)));
}
function ItemTooltipIcon() {
    return (React.createElement(StyledTieredSelectIcon, { alignItems: "center", justifyContent: "center" },
        React.createElement(Help, null)));
}
var QuickCreateInput = React.forwardRef(function QuickCreateInput(_a, ref) {
    var autoFocus = _a.autoFocus, onSubmit = _a.onSubmit, placeholder = _a.placeholder;
    function onKeyDown(e) {
        if (e.key === 'Enter') {
            onSubmit(e.currentTarget.value);
        }
    }
    return (React.createElement(Box, { flexGrow: "1", justifyContent: "center", padding: "md" },
        React.createElement(Input, { autoFocus: autoFocus, onKeyDown: onKeyDown, placeholder: placeholder, ref: ref })));
});
function Options(_a) {
    var children = _a.children, emptyMessage = _a.emptyMessage, props = __rest(_a, ["children", "emptyMessage"]);
    if (React.Children.count(children) === 0) {
        return (React.createElement(MenuImperative.Options, null,
            React.createElement(Box, __assign({ paddingLeft: "lg" }, props),
                React.createElement(Typography, { color: "gray45", intent: "small", italic: true }, emptyMessage))));
    }
    return React.createElement(MenuImperative.Options, null, children);
}
export var TieredSelectMenu = React.forwardRef(function TieredSelectMenu(_a, ref) {
    var children = _a.children, currentTier = _a.currentTier, loading = _a.loading, loadingMore = _a.loadingMore, menuRef = _a.menuRef, onChange = _a.onChange, onNavigate = _a.onNavigate, onSearch = _a.onSearch, options = _a.options, previousValue = _a.previousValue, value = _a.value, props = __rest(_a, ["children", "currentTier", "loading", "loadingMore", "menuRef", "onChange", "onNavigate", "onSearch", "options", "previousValue", "value"]);
    var _b = React.useContext(TieredSelectContext), getGroupId = _b.getGroupId, getId = _b.getId, getLabel = _b.getLabel, getNextGroupId = _b.getNextGroupId, i18nScope = _b.i18nScope, isTierDisabled = _b.isTierDisabled, onQuickCreate = _b.onQuickCreate, onScrollBottom = _b.onScrollBottom;
    var quickCreateRef = React.useRef(null);
    var hide = useOverlayTriggerContext().hide;
    var I18n = useI18nContext();
    var _c = React.useState(false), isQuickCreating = _c[0], setIsQuickCreating = _c[1];
    var _d = React.useState(''), searchValue = _d[0], setSearchValue = _d[1];
    var searchIsEmpty = searchValue === '';
    var lastEntryInValue = value[value.length - 1];
    var internalOnSearch = React.useCallback(function (e) {
        setSearchValue(e.target.value);
        onSearch && onSearch(e);
    }, [onSearch]);
    // When searching (all options have been flattened) we dont filter by id
    var filteredOptions = React.useMemo(function () {
        return searchIsEmpty
            ? options.filter(function (tier) {
                return getGroupId(tier) === currentTier;
            })
            : options;
    }, [currentTier, getGroupId, options, searchIsEmpty]);
    useHighlightItemEffects({
        currentTier: currentTier,
        searchValue: searchValue,
        menuRef: menuRef,
        loading: loading,
        loadingMore: loadingMore,
    });
    var onNavigateHome = React.useCallback(function () {
        var _a;
        onNavigate(null, []);
        (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.highlightFirst();
    }, [menuRef, onNavigate]);
    var onBreadCrumbNavigate = React.useCallback(function (tier) {
        var _a;
        var newTier = value.indexOf(tier);
        onNavigate(getNextGroupId(tier), value.slice(0, newTier + 1));
        (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.highlightFirst();
    }, [getNextGroupId, menuRef, onNavigate, value]);
    function onNavigateForward(tier) {
        var _a;
        if (searchIsEmpty && !isQuickCreating && tier && !isLeaf(tier)) {
            // if last value was a leaf, replace it when performing next navigation
            var newValue = lastEntryInValue && isLeaf(lastEntryInValue)
                ? __spreadArray(__spreadArray([], value.slice(0, value.length - 1), true), [tier], false) : __spreadArray(__spreadArray([], value, true), [tier], false);
            onNavigate(getNextGroupId(tier), newValue);
            (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.highlightFirst();
        }
    }
    /**
     * need to skip back two levels if coming from a leaf node;
     * out from the leaf and then out of the parent. this is because
     * when tiers aren't selectectable we show the parent of the leaf
     */
    function onNavigateBackward() {
        var _a;
        if (value.length !== 0 && searchIsEmpty) {
            var newValue = void 0;
            var newTier = void 0;
            if (isLeaf(value[value.length - 1])) {
                newValue = value.slice(0, Math.max(0, value.length - 2));
                newTier = value[Math.max(0, value.length - 2)];
            }
            else {
                newValue = value.slice(0, Math.max(0, value.length - 1));
                newTier = value[value.length - 1];
            }
            !isQuickCreating && onNavigate(getGroupId(newTier), newValue);
            (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.highlightFirst();
        }
    }
    function onKeyDown(e) {
        var _a;
        var tier = (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.highlighted();
        var isDisabled = isTierDisabled === null || isTierDisabled === void 0 ? void 0 : isTierDisabled(tier);
        if (isDisabled) {
            return;
        }
        if (e.key === 'Right' || e.key === 'ArrowRight') {
            onNavigateForward(tier);
        }
        else if (e.key === 'Left' || e.key === 'ArrowLeft') {
            onNavigateBackward();
        }
    }
    var isLeaf = React.useCallback(function (tier) {
        return !getNextGroupId(tier);
    }, [getNextGroupId]);
    function onTierSelect(selection) {
        if (isLeaf(selection.item)) {
            var isSameGroup = value.length
                ? getGroupId(lastEntryInValue) === getGroupId(selection.item)
                : false;
            // if the selection is in the same group as the old selection, replace the old selection
            var newValue = isSameGroup
                ? __spreadArray(__spreadArray([], value.slice(0, value.length - 1), true), [selection.item], false) : __spreadArray(__spreadArray([], value, true), [selection.item], false);
            onChange(__assign(__assign({}, selection), { value: newValue }));
            searchValue &&
                internalOnSearch({
                    target: { value: '' },
                });
            hide(selection.event);
        }
        else {
            onNavigateForward(selection.item);
        }
    }
    // non-selectable tiers can have a leaf node in the root tier, so if selected
    // it will reopen to the root tier and we should not show breadcrumbs
    function showBreadcrumbs() {
        return (value.length &&
            searchIsEmpty &&
            !(value.length === 1 && isLeaf(value[value.length - 1])));
    }
    var menuEmptyMessage = searchIsEmpty
        ? I18n.t('emptyMessage', { scope: i18nScope })
        : I18n.t('searchEmptyMessage', { scope: i18nScope });
    var handleQuickCreate = React.useCallback(function (e) {
        // stops menu from selecting item and closing on enter press
        e.stopPropagation();
        if (e.key === 'Enter') {
            setIsQuickCreating(true);
        }
    }, [setIsQuickCreating]);
    var onQuickCreateSubmit = React.useCallback(function () {
        onQuickCreate &&
            quickCreateRef.current &&
            onQuickCreate(quickCreateRef.current.value);
        setIsQuickCreating(false);
    }, [onQuickCreate, quickCreateRef, setIsQuickCreating]);
    function isTierSelected(tier) {
        if (previousValue.length) {
            return getId(tier) === getId(previousValue[previousValue.length - 1]);
        }
        return false;
    }
    function RenderMenuItem(_a) {
        var tier = _a.tier, index = _a.index;
        var tooltip = (isTierDisabled === null || isTierDisabled === void 0 ? void 0 : isTierDisabled(tier)) || false;
        var isDisabled = Boolean(tooltip);
        var showNextTierArrow = !tooltip && (Boolean(getNextGroupId(tier)) || Boolean(onQuickCreate));
        var overlay = typeof tooltip === 'string' ? tooltip : null;
        var MenuItem = (React.createElement(StyledTieredSelectOption, { disabled: isDisabled, item: tier, selected: isTierSelected(tier) },
            React.createElement(React.Fragment, null,
                getLabel(tier),
                showNextTierArrow && (React.createElement(Box, { paddingLeft: "sm" },
                    React.createElement(ArrowButton, { "data-qa": "tiered-select-arrow", onClick: function () { return onNavigateForward(tier); } }))),
                tooltip && (React.createElement(Box, { paddingLeft: "sm" },
                    React.createElement(ItemTooltipIcon, null))))));
        if (isDisabled && overlay) {
            return (React.createElement(Tooltip, { key: "".concat(getId(tier), "-").concat(index, "-tooltip"), overlay: overlay, trigger: 'hover', placement: "right" }, MenuItem));
        }
        return MenuItem;
    }
    function RenderLoadingMore() {
        if (loadingMore && !loading) {
            return (React.createElement(StyledTieredSelectLoadingMore, { "data-qa": "tiered-select-loading-more" },
                React.createElement(Spinner, { size: "sm" })));
        }
        return null;
    }
    return (React.createElement(StyledTieredSelectOverlay, { ref: ref, shadowStrength: 2 },
        React.createElement(StyledTieredSelectSpinnerOverlay, { "data-qa": "tiered-select-loading", "data-loading": loading, label: I18n.t('spinnerLabel', { scope: i18nScope }) || '', loading: loading, size: "md" },
            React.createElement(StyledTieredSelect, __assign({ onKeyDown: onKeyDown, onScrollBottom: onScrollBottom, onSelect: onTierSelect, ref: menuRef }, props),
                React.createElement(MenuImperative.Header, null,
                    !isQuickCreating && (React.createElement(MenuImperative.Search, { autoComplete: "false", autoFocus: true, onChange: internalOnSearch, placeholder: I18n.t('searchPlaceholder', {
                            scope: i18nScope,
                        }) })),
                    showBreadcrumbs() ? (React.createElement(StyledTieredSelectBreadcrumbs, { "$nonInteractive": isQuickCreating },
                        React.createElement(Breadcrumbs.Crumb, { onClick: onNavigateHome },
                            React.createElement(StyledTieredSelectHome, { alignItems: "center", justifyContent: "center" },
                                React.createElement(Home, { "data-qa": "tiered-select-home" }))),
                        value
                            .filter(function (tier) {
                            // we reopen to the parent of leaf nodes, so don't show that breadcrumb
                            return !isLeaf(tier);
                        })
                            .map(function (tier, index, array) {
                            return (React.createElement(Breadcrumbs.Crumb, { active: index === array.length - 1, key: "".concat(getId(tier), "-").concat(index), onClick: function () { return onBreadCrumbNavigate(tier); } }, getLabel(tier)));
                        }))) : null),
                !isQuickCreating ? (React.createElement(Options, { emptyMessage: menuEmptyMessage }, filteredOptions
                    .map(function (tier, index) { return (React.createElement(RenderMenuItem, { key: "menu-item-".concat(getId(tier), "-").concat(index, "}"), tier: tier, index: index })); })
                    .concat(React.createElement(RenderLoadingMore, { key: "tiered-select-loading-more" })))) : (React.createElement(QuickCreateInput, { autoFocus: isQuickCreating, onSubmit: onQuickCreateSubmit, placeholder: I18n.t('quickCreatePlaceholder', {
                        scope: i18nScope,
                    }), ref: quickCreateRef })),
                onQuickCreate && (React.createElement(MenuImperative.Footer, { "data-something": "true" }, isQuickCreating ? (React.createElement(FlexList, { size: "xs", justifyContent: "flex-end" },
                    React.createElement(Button, { onClick: function () { return setIsQuickCreating(false); }, size: "sm", variant: "tertiary" }, I18n.t('quickCreateCancelLabel', {
                        scope: i18nScope,
                    })),
                    React.createElement(Button, { onClick: onQuickCreateSubmit, size: "sm" }, I18n.t('quickCreateCreateLabel', {
                        scope: i18nScope,
                    })))) : (React.createElement(Button, { block: true, size: "sm", icon: React.createElement(Plus, null), onClick: function () { return setIsQuickCreating(true); }, onKeyDown: handleQuickCreate }, I18n.t('quickCreateActionLabel', {
                    scope: i18nScope,
                }))))),
                React.createElement(CloseOnFocus, { hide: hide })))));
});
//# sourceMappingURL=TieredSelectMenu.js.map